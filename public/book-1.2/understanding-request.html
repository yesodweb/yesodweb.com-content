<!doctype html><!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]--><!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]--><!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en"> <!--<![endif]--><head><meta charset="UTF-8"><title>Understanding a Request :: Yesod Web Framework Book- Version 1.2</title><meta name="description" content="Yesod is a Haskell web framework for productive development of type-safe, RESTful, high performance web applications."><meta name="viewport" content="width=device-width,initial-scale=1"><link href="/feed" type="application/atom+xml" rel="alternate" title="Yesod Web Framework Blog">
<style>article,aside,details,figcaption,figure,footer,header,hgroup,nav,section{display:block}audio,canvas,video{display:inline-block;*display:inline;*zoom:1}audio:not([controls]){display:none}[hidden]{display:none}html{font-size:100%;overflow-y:scroll;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}body,button,input,select,textarea{font-family:sans-serif}a{color:#00e}a:visited{color:#551a8b}a:focus{outline:thin dotted}a:hover,a:active{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}blockquote{margin:1em 40px}dfn{font-style:italic}mark{background:#ff0;color:#000}pre,code,kbd,samp{font-family:"DejaVu Sans Mono", "Droid Sans Mono", consolas, "courier new", monospace;_font-family:'courier new', monospace;font-size:.85em}pre{white-space:pre;white-space:pre-wrap;word-wrap:break-word}q{quotes:none}q:before,q:after{content:'';content:none}small{font-size:75%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}ul,ol{margin:1em 0;padding:0 0 0 40px}dd{margin:0 0 0 40px}nav ul,nav ol{list-style:none;list-style-image:none}img{border:0;-ms-interpolation-mode:bicubic}svg:not(:root){overflow:hidden}figure{margin:0}form{margin:0}fieldset{margin:0 2px;padding:0.35em 0.625em 0.75em}legend{border:0;*margin-left:-7px}button,input,select,textarea{font-size:100%;margin:0;vertical-align:baseline;*vertical-align:middle}button,input{line-height:normal;*overflow:visible}table button,table input{*overflow:auto}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}pre code{display:block;padding:0.5em;background:#F4F4F4}pre code,pre .ruby .subst,pre .tag .title,pre .lisp .title{color:black}pre .string,pre .title,pre .constant,pre .parent,pre .tag .value,pre .rules .value,pre .rules .value .number,pre .preprocessor,pre .ruby .symbol,pre .ruby .symbol .string,pre .ruby .symbol .keyword,pre .ruby .symbol .keymethods,pre .instancevar,pre .aggregate,pre .template_tag,pre .django .variable,pre .smalltalk .class,pre .addition,pre .flow,pre .stream,pre .bash .variable,pre .apache .tag,pre .apache .cbracket,pre .tex .command,pre .tex .special,pre .erlang_repl .function_or_atom{color:#800}pre .comment,pre .annotation,pre .template_comment,pre .diff .header,pre .chunk{color:#888}pre .number,pre .date,pre .regexp,pre .literal,pre .smalltalk .symbol,pre .smalltalk .char,pre .go .constant,pre .change{color:#080}pre .label,pre .javadoc,pre .ruby .string,pre .decorator,pre .filter .argument,pre .localvars,pre .array,pre .attr_selector,pre .important,pre .pseudo,pre .pi,pre .doctype,pre .deletion,pre .envvar,pre .shebang,pre .apache .sqbracket,pre .nginx .built_in,pre .tex .formula,pre .erlang_repl .reserved,pre .input_number{color:#88F
}pre .css .tag,pre .javadoctag,pre .phpdoc,pre .yardoctag{font-weight:bold}pre .keyword,pre .id,pre .phpdoc,pre .title,pre .built_in,pre .aggregate,pre .smalltalk .class,pre .winutils,pre .bash .variable,pre .apache .tag,pre .go .typename,pre .tex .command{font-weight:bold}pre .nginx .built_in{font-weight:normal}pre .xml .css,pre .xml .javascript,pre .xml .vbscript,pre .tex .formula{opacity:0.5}aside.note{padding:0.5em;border:1px dotted #000}.github-link{font-size:0.6em}.github-link a,.github-link a:visited{text-decoration:none}article > h1:first-child{margin-top:0}figure > h1{margin:0}p code{background-color:#f0f0f0}a.permalink{font-size:50%;text-decoration:none;position:absolute;left:-25px;top:10px}section > h1{position:relative}pre > code{white-space:pre;overflow-x:auto}@media print, (max-width: 700px) {article > h1:first-child{margin-top:25px}section > h1{margin-bottom:0.5em}}.warning{color:red;font-weight:bold}#main figure{border:1px solid #CCC;box-shadow:0 0 3px #CCC inset;padding:1em;margin:2ex 0}#main figure figcaption{text-size:.9em;text-align:center;color:#555}#main figure img{border:solid 1px #CCC}#container{min-width:1094px}dd,p{text-align:justify}body{font-family:'Crimson Text', serif;font-size:1.2em;background-color:#e5eef9}a,a:visited{color:#000}a:hover,a:active{color:#823}nav{box-shadow:0 -5px 20px 20px rgba(41,55,78,0.12);z-index:100;background-color:#29374e;padding:5px;font-family:'Lato';font-size:0.80em;font-weight:400;position:fixed;width:100%;top:0}nav ul{margin:0;padding:0;text-align:right}nav ul li{display:inline;margin-right:3em}nav ul li.googleplus{position:relative;top:2px;margin-right:3em}nav ul li.feedlink{position:relative;top:3px}nav a,nav a:visited{color:#eee;text-decoration:none}#spotlight{background-image:-webkit-radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);background-image:-moz-radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);background-image:-o-radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);background-image:-ms-radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);background-image:radial-gradient(50% 50%, circle farthest-side, #fff, #e5eef9 100%);position:absolute;width:1050px;height:300px;top:0;left:50%;margin-left:-475px;z-index:-1}div.headergroup{width:1050px;margin:0 auto;padding-top:2.6em;padding-bottom:1.3em}div.headergroup a{text-decoration:none;display:flex}div.headergroup div.homepage-logo{text-align:center;width:550px;height:105px;margin-left:75px}div.headergroup div.homepage-logo div.logo-image{background:url(/static/logo-home2-no-esod-smaller2.png?etag=uBLSXtRu) no-repeat center center;width:100%;height:75px}div.headergroup div.homepage-logo div.logo-text{color:#29374e;padding-top:0.2em;font-family:'Lato';font-weight:300;font-size:1.2em;padding-bottom:0.3em}div.headergroup div.homepage-info{text-align:left;font-family:'Lato';font-weight:300;font-size:0.8em;line-height:1.6em;width:220px}div.headergroup h2{margin-bottom:0;font-size:1.4em;margin-top:0;padding-top:0.4em;padding-bottom:1em}h1,h2,h3,h4,h5,h6,dt{color:#474f6b;font-family:'Lato';font-weight:400}h1{font-weight:300;font-size:1.8em}h2,section > section > h1{font-weight:400;font-size:1.5em;margin-bottom:0.5em}h3,section > section > section > h1{font-weight:400;font-size:1.2em;margin-bottom:0.5em}h1 span{display:none}section{display:table-cell}section h2{margin-top:2.2em;margin-bottom:0}section img{max-width:100%}section section{display:block;width:auto;padding:0;margin:0}section.why{width:600px;padding-left:90px;padding-right:90px}section.why article{width:600px}section.getting-started{background-color:#f4f4f4;width:300px;padding-left:50px;padding-right:50px}section.getting-started h2{font-size:1.2em;margin-bottom:0.7em;margin-top:1.8em}section.getting-started ul{font-family:'Lato';font-size:0.75em;font-weight:500;margin-bottom:20px;line-height:2em;list-style-type:none;margin-bottom:50px;padding-left:0}section.getting-started ul ul{font-size:.9em }section.getting-started div{font-family:'Lato';padding-left:20px}#main{box-shadow:0 10px 25px 25px rgba(41,55,78,0.05);background-color:#fff;position:relative;width:1050px;margin:0 auto}aside#announcement{box-shadow:0 0 20px 10px rgba(41,55,78,0.12);height:20px;margin:0 auto;position:relative;width:1080px;background-color:#29374e;color:#eee;padding:0.5em;font-family:'Lato';font-weight:400;font-size:0.8em;z-index:50}aside#announcement div.msg{margin-left:105px}aside#announcement div.tri-left,aside#announcement div.tri-right{width:0;height:0;position:absolute;bottom:-21px;border-style:solid}aside#announcement div.tri-left{left:0;border-width:11px 11px 10px 11px;border-color:#0b1b30 #0b1b30 transparent transparent}aside#announcement div.tri-right{right:0;border-width:11px 11px 11px 10px;border-color:#0b1b30 transparent transparent #0b1b30}aside#announcement a,aside#announcement a:visited{color:#eee;text-decoration:underline}aside#announcement span.date{font-style:italic;font-size:0.8em}#feedlink{display:inline-block;height:16px;width:16px;background:url(/static/blog.png?etag=oPHrQ5qo)}#feedlink span{display:none}dt{font-weight:400;font-size:1.05em;margin-bottom:0.7em;margin-top:2.3em}dd,p{margin:0;font-size:1em;line-height:155%;margin-bottom:0.5em}p.what{display:none;font-size:1.4em;padding:0 200px}#instantclick{display:none}@media print, (max-width: 700px) {body{background-color:#fff;padding:3px}.googleplus,.feedlink,.headergroup,#announcement,#comments,#disqus_thread,#spotlight,#license,.github-link,.oreilly,.main-listing{display:none}div .headergroup{display:none}#container > nav{background-color:#fff;box-shadow:none}#container > nav > ul{text-align:left}#container > nav > ul a,#container > nav > ul a:visited{color:#00f}#main,div#container,section.why > article{width:auto;min-width:0}#main{box-shadow:none;position:static;margin:0}section.why,section.getting-started{display:block;width:auto;padding:0;background-color:#fff}hgroup h1[itemprop=name],hgroup h2,hgroup h3{margin:0}hgroup h1[itemprop=name] img,hgroup h2 img,hgroup h3 img{display:none}dd,p,dt{margin:12px}}@media print {nav{display:none}section.getting-started{display:none}}</style><!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><link href="//fonts.googleapis.com/css?family=Crimson+Text:400,400italic,600,600italic,700,700italic" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic" rel="stylesheet" type="text/css"><script>document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/,'js');</script></head><body itemscope itemtype="http://schema.org/Product"><div id="spotlight"></div><div id="container"><nav><ul><li><a href="/book">book</a></li><li><a href="/wiki">cookbook</a></li><li><a href="/blog">blog</a></li><li><a href="/wiki/Home">wiki</a></li><li class="feedlink"><a href="/feed" id="feedlink"><span>newsfeed</span></a></li></ul></nav><div class="headergroup"><a href="/"><div class="homepage-logo"><div class="logo-image"></div><div class="logo-text">Yesod Web Framework</div></div><div class="homepage-info">Yesod is a Haskell web framework for productive development of type-safe, RESTful, high performance web applications.</div></a></div><aside id="announcement"><div class="tri-left"></div><div class="tri-right"></div><div class="msg"><span class="subject">Understanding a Request :: Yesod Web Framework Book- Version 1.2</span></div></aside><div id="main" role="main"><section class="why"><p class="github-link"><a href="https://github.com/yesodweb/yesodweb.com-content/tree/version1.2/book/understanding-request.asciidoc">View source on Github</a>
</p>
<article><h1>Understanding a Request</h1>


<p>You can often times get away with using Yesod for quite a while without needing
to understand its internal workings. However, such an understanding is often
times advantageous. This chapter will walk you through the request handling
process for a fairly typical Yesod application. Note that a fair amount of this
discussion involves code changes in Yesod 1.2. Most of the concepts are the
same in previous versions, though the data types involved were a bit messier.</p>
<p>Yesod’s usage of Template Haskell to bypass boilerplate code can make it
a bit difficult to understand this process sometimes. If beyond the information
in this chapter you wish to further analyze things, it can be useful to view
GHC’s generated code using -ddump-splices.</p>
<aside class="note">
<p>A lot of this information was originally published as a blog series on the 1.2 release. You can see the blog posts at:</p>
<ul>
<li>
<p>
<a href="http://www.yesodweb.com/blog/2013/03/yesod-1-2-cleaner-internals">Yesod 1.2’s cleaner internals</a>
</p>
</li>
<li>
<p>
<a href="http://www.yesodweb.com/blog/2013/03/big-subsite-rewrite">Big Subsite Rewrite</a>
</p>
</li>
<li>
<p>
<a href="http://www.yesodweb.com/blog/2013/03/yesod-dispatch-version-1-2">Yesod dispatch, version 1.2</a>
</p>
</li>
</ul>
</aside>
<section id="understanding-request_handlers">
<h1>Handlers</h1>
<p>When trying to understand Yesod request handling, we need to look at two
components: how a request is dispatched to the appropriate handler code, and
how handler functions are processed. We’ll start off with the latter, and
then circle back to understanding the dispatch process itself.</p>
<section id="understanding-request_layers">
<h1>Layers</h1>
<p>Yesod builds itself on top of WAI, which provides a protocol for web servers
(or, more generally, <em>handlers</em>) and applications to communicate with each
other. This is expressed through two datatypes: Request and Response. Then, an
Application is defined as type <code>Application = Request -&gt; ResourceT IO
Response</code>. A WAI handler will take an application and run it.</p>
<p>Request and Response are both very low-level, trying to represent the HTTP
protocol without too much embellishment. This keeps WAI as a generic tool, but
also leaves out a lot of the information we need in order to implement a web
framework. For example, WAI will provide us with the raw data for all request
headers. But Yesod needs to parse that to get cookie information, and then
parse the cookies in order to extract session information.</p>
<p>To deal with this dichotomy, Yesod introduces two new data types:
<code>YesodRequest</code> and <code>YesodResponse</code>. <code>YesodRequest</code> contains a WAI Request, and
also adds in such request information as cookies and session variables, and on
the response side can either be a standard WAI Response, or be a higher-level
representation of such a response including such things as updated session
information and extra response headers. To parallel WAI’s Application, we
have <code>type YesodApp = YesodRequest -&gt; ResourceT IO YesodResponse</code>.</p>
<p>But as a Yesod user, you never really see YesodApp. There’s another layer
on top of that which you are used to dealing with: Handler. When you write
handler functions, you need to have access to three different things:</p>
<ul>
<li>
<p>
The YesodRequest value for the current request.
</p>
</li>
<li>
<p>
Some basic environment information, like how to log messages or handle error conditions. This is provided by the datatype RunHandlerEnv.
</p>
</li>
<li>
<p>
A mutable variable to keep track of updateable information, such as the headers to be returned and the user session state. This is called GHState.
</p>
</li>
</ul>
<aside class="note"><p>I know that’s not a great name, but it’s there for historical reasons.</p></aside>
<p>So when you’re writing a handler function, you’re essentially just
writing in a Reader monad that has access to all of this information. The
runHandler function will turn a Handler into a YesodApp. yesodRunner takes this
a step further and converts all the way to a WAI Application.</p>
</section>
<section id="understanding-request_content">
<h1>Content</h1>
<p>Our example above, and many others you’ve already seen, give a handler
with a type of Handler Html. We’ve just described what the Handler means,
but how does Yesod know how to deal with Html? The answer lies in the
ToTypedContent typeclass. The relevants bit of code are:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">data Content = ContentBuilder !BBuilder.Builder !(Maybe Int) -- ^ The content and optional content length.
             | ContentSource !(Source (ResourceT IO) (Flush BBuilder.Builder))
             | ContentFile !FilePath !(Maybe FilePart)
             | ContentDontEvaluate !Content
data TypedContent = TypedContent !ContentType !Content

class ToContent a where
    toContent :: a -&gt; Content
class ToContent a =&gt; ToTypedContent a where
    toTypedContent :: a -&gt; TypedContent</code></pre>
<p>The Content datatype represents the different ways you can provide a response
body. The first three mirror WAI’s representation directly. The fourth
(ContentDontEvaluate) is used to indicate to Yesod whether response bodies
should be fully evaluated before being returned to users. The advantage to
fully evaluating is that we can provide meaningful error messages if an
exception is thrown from pure code. The downside is possibly increased time and
memory usage.</p>
<p>In any event, Yesod knows how to turn a Content into a response body. The
ToContent typeclass provides a way to allow many different datatypes to be
converted into response bodies. Many commonly used types are already instances
of ToContent, including strict and lazy ByteString and Text, and of course
Html.</p>
<p>TypedContent adds an extra piece of information: the content type of the value.
As you might expect, there are ToTypedContent instances for a number of common
datatypes, including HTML, JSON, and plain text.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">instance ToTypedContent J.Value where
    toTypedContent v = TypedContent typeJson (toContent v)
instance ToTypedContent Html where
    toTypedContent h = TypedContent typeHtml (toContent h)
instance ToTypedContent T.Text where
    toTypedContent t = TypedContent typePlain (toContent t)</code></pre>
<p>Putting this all together: a Handler is able to return any value which is an
instance of ToTypedContent, and Yesod will handle turning it into an
appropriate representation and setting the Content-Type response header.</p>
</section>
<section id="understanding-request_short_circuit_responses">
<h1>Short-circuit responses</h1>
<p>One other oddity is how short-circuiting works. For example, you can call
redirect in the middle of a handler function, and the rest of the function will
not be called. The mechanism we use is standard Haskell exceptions. Calling
redirect just throws an exception of type HandlerContents. The runHandler
function will catch any exceptions thrown and produce an appropriate response.
For HandlerContents, each constructor gives a clear action to perform, be it
redirecting or sending a file. For all other exception types, an error message
is displayed to the user.</p>
</section>
</section>
<section id="understanding-request_dispatch">
<h1>Dispatch</h1>
<p>Dispatch is the act of taking an incoming request and generating an appropriate
response. We have a few different constraints regarding how we want to handle
dispatch:</p>
<ul>
<li>
<p>
Dispatch based on path segments (or pieces).
</p>
</li>
<li>
<p>
Optionally dispatch on request method.
</p>
</li>
<li>
<p>
Support subsites: packaged collections of functionality providing multiple routes under a specific URL prefix.
</p>
</li>
<li>
<p>
Support using WAI applications as subsites, while introducing as little
  runtime overhead to the process as possible. In particular, we want to avoid
  performing any unnecessary parsing to generate a YesodRequest if it
  won’t be used.
</p>
</li>
</ul>
<p>The lowest common denominator for this would be to simply use a WAI
Application. However, this doesn’t provide quite enough information: we
need access to the foundation datatype, the logger, and for subsites how a
subsite route is converted to a parent site route. To address this, we have two
helper data types (YesodRunnerEnv and YesodSubRunnerEnv) providing this extra
information for normal sites and subsites.</p>
<p>With those types, dispatch now becomes a relatively simple matter: give me an
environment and a request, and I’ll give you a response. This is
represented by the typeclasses YesodDispatch and YesodSubDispatch:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">class Yesod site =&gt; YesodDispatch site where
    yesodDispatch :: YesodRunnerEnv site -&gt; W.Application

class YesodSubDispatch sub m where
    yesodSubDispatch :: YesodSubRunnerEnv sub (HandlerSite m) m
                     -&gt; W.Application</code></pre>
<p>We’ll see a bit later how YesodSubDispatch is used. Let’s first
understand how YesodDispatch comes into play,__</p>
<section id="understanding-request_towaiapp_towaiappplain_and_warp">
<h1>toWaiApp, toWaiAppPlain, and warp</h1>
<p>Let’s assume for the moment that you have a datatype which is an instance
of YesodDispatch. You’ll want to now actually run this thing somehow. To
do this, we need to convert it into a WAI application and pass it to some kind
of a WAI handler/server. To start this journey, we use toWaiAppPlain. It
performs any appwide initialization necessary. At the time of writing, this
means allocating a logger and setting up the session backend, but more
functionality may be added in the future. Using this data, we can now create a
YesodRunnerEnv. And when that value is passed to yesodDispatch, we get a WAI
application.</p>
<p>We’re almost done. The final remaining modification is path segment
cleanup. The Yesod typeclass includes a member function named cleanPath which
can be used to create canonical URLs. For example, the default implementation
would remove double slashes and redirect a user from <code>/foo//bar</code> to <code>/foo/bar</code>.
toWaiAppPlain adds in some pre-processing to the normal WAI request by
analyzing the requested path and performing cleanup/redirect as necessary.</p>
<p>At this point, we have a fully functional WAI application. There are two other
helper functions included. toWaiApp wraps toWaiAppPlain and additionally
includes some commonly used WAI middlewares, including request logging and GZIP
compression. (Please see the Haddocks for an up-to-date list.) We finally have
the warp function which, as you might guess, runs your application with Warp.</p>
<aside class="note"><p>There’s also the warpEnv function, which reads the port number
information from the PORT environment variable. This is used for interacting
with certain tools, including the Keter deployment manager and the FP Complete
School of Haskell.</p></aside>
</section>
<section id="understanding-request_generated_code">
<h1>Generated code</h1>
<p>The last remaining black box is the Template Haskell generated code. This
generated code is responsible for handling some of the tedious, error-prone
pieces of your site. If you want to, you can write these all by hand instead.
We’ll demonstrate what that translation would look like, and in the
process elucidate how YesodDispatch and YesodSubDispatch work. Let’s
start with a fairly typical Yesod application.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell active web">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE TemplateHaskell   #-}
{-# LANGUAGE TypeFamilies      #-}
import qualified Data.ByteString.Lazy.Char8 as L8
import           Network.HTTP.Types         (status200)
import           Network.Wai                (pathInfo, rawPathInfo,
                                             requestMethod, responseLBS)
import           Yesod

data App = App

mkYesod &quot;App&quot; [parseRoutes|
/only-get       OnlyGetR   GET
/any-method     AnyMethodR
/has-param/#Int HasParamR  GET
/my-subsite     MySubsiteR WaiSubsite getMySubsite
|]

instance Yesod App

getOnlyGetR :: Handler Html
getOnlyGetR = defaultLayout
    [whamlet|
        &lt;p&gt;Accessed via GET method
        &lt;form method=post action=@{AnyMethodR}&gt;
            &lt;button&gt;POST to /any-method
    |]

handleAnyMethodR :: Handler Html
handleAnyMethodR = do
    req &lt;- waiRequest
    defaultLayout
        [whamlet|
            &lt;p&gt;In any-method, method == #{show $ requestMethod req}
        |]

getHasParamR :: Int -&gt; Handler String
getHasParamR i = return $ show i

getMySubsite :: App -&gt; WaiSubsite
getMySubsite _ =
    WaiSubsite app
  where
    app req = return $ responseLBS
        status200
        [(&quot;Content-Type&quot;, &quot;text/plain&quot;)]
        $ L8.pack $ concat
            [ &quot;pathInfo == &quot;
            , show $ pathInfo req
            , &quot;, rawPathInfo == &quot;
            , show $ rawPathInfo req
            ]

main :: IO ()
main = warp 3000 App</code></pre>
<p>For completeness we’ve provided a full listing, but let’s focus on
just the Template Haskell portion:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">mkYesod &quot;App&quot; [parseRoutes|
/only-get       OnlyGetR   GET
/any-method     AnyMethodR
/has-param/#Int HasParamR  GET
/my-subsite     MySubsiteR WaiSubsite getMySubsite
|]</code></pre>
<p>While this generates a few pieces of code, we only need to replicate three
components to make our site work. Let’s start with the simplest: the
Handler type synonym:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">type Handler = HandlerT App IO</code></pre>
<p>Next is the type-safe URL and its rendering function. The rendering function is
allowed to generate both path segments and query string parameters. Standard
Yesod sites never generate query-string parameters, but it is technically
possible. And in the case of subsites, this often does happen. Notice how we
handle the qs parameter for the MySubsiteR case:</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">instance RenderRoute App where
    data Route App = OnlyGetR
                   | AnyMethodR
                   | HasParamR Int
                   | MySubsiteR (Route WaiSubsite)
        deriving (Show, Read, Eq)

    renderRoute OnlyGetR = ([&quot;only-get&quot;], [])
    renderRoute AnyMethodR = ([&quot;any-method&quot;], [])
    renderRoute (HasParamR i) = ([&quot;has-param&quot;, toPathPiece i], [])
    renderRoute (MySubsiteR subRoute) =
        let (ps, qs) = renderRoute subRoute
         in (&quot;my-subsite&quot; : ps, qs)</code></pre>
<p>You can see that there’s a fairly simple mapping from the higher-level
route syntax and the RenderRoute instance. Each route becomes a constructor,
each URL parameter becomes an argument to its constructor, we embed a route for
the subsite, and use toPathPiece to render parameters to text.</p>
<p>The final component is the YesodDispatch instance. Let’s look at this in
a few pieces.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">instance YesodDispatch App where
    yesodDispatch env req =
        case pathInfo req of
            [&quot;only-get&quot;] -&gt;
                case requestMethod req of
                    &quot;GET&quot; -&gt; yesodRunner
                        getOnlyGetR
                        env
                        (Just OnlyGetR)
                        req
                    _ -&gt; yesodRunner
                        (badMethod &gt;&gt; return ())
                        env
                        (Just OnlyGetR)
                        req</code></pre>
<p>As described above, yesodDispatch is handed both an environment and a WAI
Request value. We can now perform dispatch based on the requested path, or in
WAI terms, the pathInfo. Referring back to our original high-level route
syntax, we can see that our first route is going to be the single piece
only-get, which we pattern match for.</p>
<aside class="note"><p>In reality, Yesod generates a much more efficient data structure to
perform routing. We’ve used simple pattern matching here so as not to
obscure the point. For more information, please see the
<a href="https://github.com/yesodweb/yesod/blob/master/yesod-routes/Yesod/Routes/Dispatch.lhs">Yesod.Routes.Dispatch</a>.</p></aside>
<p>Once that match has succeeded, we additionally pattern match on the request
method; if it’s <code>GET</code>, we use the handler function getOnlyGetR.
Otherwise, we want to return a 405 bad method response, and therefore use the
badMethod handler. At this point, we’ve come full circle to our original
handler discussion. You can see that we’re using yesodRunner to execute
our handler function. As a reminder, this will take our environment and WAI
Request, convert it to a YesodRequest, constructor a RunHandlerEnv, hand that
to the handler function, and then convert the resulting YesodResponse into a
WAI Response.</p>
<p>Wonderful; one down, three to go. The next one is even easier.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">            [&quot;any-method&quot;] -&gt;
                yesodRunner handleAnyMethodR env (Just AnyMethodR) req</code></pre>
<p>Unlike OnlyGetR, AnyMethodR will work for any request method, so we don’t
need to perform any further pattern matching.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">            [&quot;has-param&quot;, t] | Just i &lt;- fromPathPiece t -&gt;
                case requestMethod req of
                    &quot;GET&quot; -&gt; yesodRunner
                        (getHasParamR i)
                        env
                        (Just $ HasParamR i)
                        req
                    _ -&gt; yesodRunner
                        (badMethod &gt;&gt; return ())
                        env
                        (Just $ HasParamR i)
                        req</code></pre>
<p>We add in one extra complication here: a dynamic parameter. While we used
toPathPiece to render to a textual value above, we now use fromPathPiece to
perform the parsing. Assuming the parse succeeds, we then follow a very similar
dispatch system as was used for OnlyGetR. The prime difference is that our
parameter needs to be passed to both the handler function and the route data
constructor.</p>
<p>Next we’ll look at the subsite, which is quite different.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell">            (&quot;my-subsite&quot;:rest) -&gt; yesodSubDispatch
                YesodSubRunnerEnv
                    { ysreGetSub = getMySubsite
                    , ysreParentRunner = yesodRunner
                    , ysreToParentRoute = MySubsiteR
                    , ysreParentEnv = env
                    }
                req { pathInfo = rest }</code></pre>
<p>Unlike the other pattern matches, here we just look to see if our pattern
prefix matches. Any route beginning with <code>/my-subsite</code> should be passed off to
the subsite for processing. This is where we finally get to use
yesodSubDispatch. This function closely mirrors yesodDispatch. We need to
construct a new environment to be passed to it. Let’s discuss the four
records:</p>
<ul>
<li>
<p>
ysreGetSub demonstrates how to get the subsite foundation type from the
  master site. We provide getMySubsite, which is the function we provided in
  the high-level route syntax.
</p>
</li>
<li>
<p>
ysreParentRunner provides a means of running a handler function. It may seem
  a bit boring to just provide yesodRunner, but by having a separate parameter
  we allow the construction of deeply nested subsites, which will wrap and
  unwrap many layers of interleaving subsites. (This is a more advanced concept
  which we won’t be covering in this chapter.)
</p>
</li>
<li>
<p>
ysreToParentRoute will convert a route for the subsite into a route for the
  parent site. This is the purpose of the MySubsiteR constructor. This allows
  subsites to use functions such as getRouteToParent.
</p>
</li>
<li>
<p>
ysreParentEnv simply passes on the initial environment, which contains a
  number of things the subsite may need (such as logger).
</p>
</li>
</ul>
<p>The other interesting thing is how we modify the pathInfo. This allows subsites
to <em>continue dispatching</em> from where the parent site left off. To demonstrate
how this works, see some screenshots of various requests in the following
figure.</p>
<figure><h1>Path info in subsite</h1>

  
  <img src="/static/bookimage/subsite-path-info.png" />
  
  

</figure>
<p>And finally, not all requests will be valid routes. For those cases, we just
want to respond with a 404 not found.</p>
<pre>            _ -&gt; yesodRunner (notFound &gt;&gt; return ()) env Nothing req</pre>
</section>
<section id="understanding-request_complete_code">
<h1>Complete code</h1>
<p>Following is the full code for the non-Template Haskell approach.</p>
<pre language="haskell" linenumbering="unnumbered"><code class="haskell active web">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE TemplateHaskell   #-}
{-# LANGUAGE TypeFamilies      #-}
import qualified Data.ByteString.Lazy.Char8 as L8
import           Network.HTTP.Types         (status200)
import           Network.Wai                (pathInfo, rawPathInfo,
                                             requestMethod, responseLBS)
import           Yesod
import           Yesod.Core.Types           (YesodSubRunnerEnv (..))

data App = App

instance RenderRoute App where
    data Route App = OnlyGetR
                   | AnyMethodR
                   | HasParamR Int
                   | MySubsiteR (Route WaiSubsite)
        deriving (Show, Read, Eq)

    renderRoute OnlyGetR = ([&quot;only-get&quot;], [])
    renderRoute AnyMethodR = ([&quot;any-method&quot;], [])
    renderRoute (HasParamR i) = ([&quot;has-param&quot;, toPathPiece i], [])
    renderRoute (MySubsiteR subRoute) =
        let (ps, qs) = renderRoute subRoute
         in (&quot;my-subsite&quot; : ps, qs)

type Handler = HandlerT App IO

instance Yesod App

instance YesodDispatch App where
    yesodDispatch env req =
        case pathInfo req of
            [&quot;only-get&quot;] -&gt;
                case requestMethod req of
                    &quot;GET&quot; -&gt; yesodRunner
                        getOnlyGetR
                        env
                        (Just OnlyGetR)
                        req
                    _ -&gt; yesodRunner
                        (badMethod &gt;&gt; return ())
                        env
                        (Just OnlyGetR)
                        req
            [&quot;any-method&quot;] -&gt;
                yesodRunner handleAnyMethodR env (Just AnyMethodR) req
            [&quot;has-param&quot;, t] | Just i &lt;- fromPathPiece t -&gt;
                case requestMethod req of
                    &quot;GET&quot; -&gt; yesodRunner
                        (getHasParamR i)
                        env
                        (Just $ HasParamR i)
                        req
                    _ -&gt; yesodRunner
                        (badMethod &gt;&gt; return ())
                        env
                        (Just $ HasParamR i)
                        req
            (&quot;my-subsite&quot;:rest) -&gt; yesodSubDispatch
                YesodSubRunnerEnv
                    { ysreGetSub = getMySubsite
                    , ysreParentRunner = yesodRunner
                    , ysreToParentRoute = MySubsiteR
                    , ysreParentEnv = env
                    }
                req { pathInfo = rest }
            _ -&gt; yesodRunner (notFound &gt;&gt; return ()) env Nothing req

getOnlyGetR :: Handler Html
getOnlyGetR = defaultLayout
    [whamlet|
        &lt;p&gt;Accessed via GET method
        &lt;form method=post action=@{AnyMethodR}&gt;
            &lt;button&gt;POST to /any-method
    |]

handleAnyMethodR :: Handler Html
handleAnyMethodR = do
    req &lt;- waiRequest
    defaultLayout
        [whamlet|
            &lt;p&gt;In any-method, method == #{show $ requestMethod req}
        |]

getHasParamR :: Int -&gt; Handler String
getHasParamR i = return $ show i

getMySubsite :: App -&gt; WaiSubsite
getMySubsite _ =
    WaiSubsite app
  where
    app req = return $ responseLBS
        status200
        [(&quot;Content-Type&quot;, &quot;text/plain&quot;)]
        $ L8.pack $ concat
            [ &quot;pathInfo == &quot;
            , show $ pathInfo req
            , &quot;, rawPathInfo == &quot;
            , show $ rawPathInfo req
            ]

main :: IO ()
main = warp 3000 App</code></pre>
</section>
</section>
<section id="understanding-request_conclusion">
<h1>Conclusion</h1>
<p>Yesod abstracts away quite a bit of the plumbing from you as a developer. Most
of this is boilerplate code that you’ll be happy to ignore. But it can be
empowering to understand exactly what’s going on under the surface. At
this point, you should hopefully be able- with help from the Haddocks- to write
a site without any of the autogenerated Template Haskell code. Not that
I’d recommend it; I think using the generated code is easier and safer.</p>
<p>One particular advantage of understanding this material is seeing where Yesod
sits in the world of WAI. This makes it easier to see how Yesod will interact
with WAI middleware, or how to include code from other WAI framework in a Yesod
application (or vice-versa!).</p>
</section>
</article>
</section>
<section class="getting-started"><p class="warning">Note: You are looking at version 1.2 of the book, which is two versions behind</p>
<h2> Chapters</h2>
<ul><li>Basics
<ul><li><a href="/book-1.2/introduction">Introduction</a>
</li>
<li><a href="/book-1.2/haskell">Haskell</a>
</li>
<li><a href="/book-1.2/basics">Basics</a>
</li>
<li><a href="/book-1.2/shakespearean-templates">Shakespearean Templates</a>
</li>
<li><a href="/book-1.2/widgets">Widgets</a>
</li>
<li><a href="/book-1.2/yesod-typeclass">Yesod Typeclass</a>
</li>
<li><a href="/book-1.2/routing-and-handlers">Routing and Handlers</a>
</li>
<li><a href="/book-1.2/forms">Forms</a>
</li>
<li><a href="/book-1.2/sessions">Sessions</a>
</li>
<li><a href="/book-1.2/persistent">Persistent</a>
</li>
<li><a href="/book-1.2/deploying-your-webapp">Deploying your Webapp</a>
</li>
</ul>
</li>
<li>Advanced
<ul><li><a href="/book-1.2/restful-content">RESTful Content</a>
</li>
<li><a href="/book-1.2/yesods-monads">Yesod’s Monads</a>
</li>
<li><a href="/book-1.2/authentication-and-authorization">Authentication and Authorization</a>
</li>
<li><a href="/book-1.2/scaffolding-and-the-site-template">Scaffolding and the Site Template</a>
</li>
<li><a href="/book-1.2/internationalization">Internationalization</a>
</li>
<li><a href="/book-1.2/creating-a-subsite">Creating a Subsite</a>
</li>
<li><a href="/book-1.2/understanding-request">Understanding a Request</a>
</li>
<li><a href="/book-1.2/yesod-for-haskellers">Yesod for Haskellers</a>
</li>
</ul>
</li>
<li>Examples
<ul><li><a href="/book-1.2/initializing-foundation-data">Initializing data in the foundation datatype</a>
</li>
<li><a href="/book-1.2/blog-example-advanced">Blog: i18n, authentication, authorization, and database</a>
</li>
<li><a href="/book-1.2/wiki-chat-example">Wiki: markdown, chat subsite, event source</a>
</li>
<li><a href="/book-1.2/json-web-service">JSON Web Service</a>
</li>
<li><a href="/book-1.2/case-study-sphinx">Case Study: Sphinx-based Search</a>
</li>
<li><a href="/book-1.2/visitor-counter">Visitor counter</a>
</li>
<li><a href="/book-1.2/single-process-pubsub">Single process pub-sub</a>
</li>
<li><a href="/book-1.2/environment-variables">Environment variables for configuration</a>
</li>
<li><a href="/book-1.2/route-attributes">Route attributes</a>
</li>
</ul>
</li>
<li>Appendices
<ul><li><a href="/book-1.2/monad-control">monad-control</a>
</li>
<li><a href="/book-1.2/conduits">Conduit</a>
</li>
<li><a href="/book-1.2/web-application-interface">Web Application Interface</a>
</li>
<li><a href="/book-1.2/settings-types">Settings Types</a>
</li>
<li><a href="/book-1.2/http-conduit">http-conduit</a>
</li>
<li><a href="/book-1.2/xml">xml-conduit</a>
</li>
</ul>
</li>
</ul>
</section>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script><script src="//ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script><script>var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function c(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function j(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function g(t,s){var r="";for(var q=0;q<t.childNodes.length;q++){if(t.childNodes[q].nodeType==3){var p=t.childNodes[q].nodeValue;if(s){p=p.replace(/\n/g,"")}r+=p}else{if(t.childNodes[q].nodeName=="BR"){r+="\n"}else{r+=g(t.childNodes[q])}}}if(/MSIE [678]/.test(navigator.userAgent)){r=r.replace(/\r/g,"\n")}return r}function a(s){var q=s.className.split(/\s+/);q=q.concat(s.parentNode.className.split(/\s+/));for(var p=0;p<q.length;p++){var r=q[p].replace(/^language-/,"");if(d[r]||r=="no-highlight"){return r}}}function b(p){var q=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{q.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);q.push({event:"stop",offset:t,node:s.childNodes[r]})}}}return t})(p,0);return q}function l(y,z,x){var r=0;var w="";var t=[];function u(){if(y.length&&z.length){if(y[0].offset!=z[0].offset){return(y[0].offset<z[0].offset)?y:z}else{return z[0].event=="start"?y:z}}else{return y.length?y:z}}function s(C){var D="<"+C.nodeName.toLowerCase();for(var A=0;A<C.attributes.length;A++){var B=C.attributes[A];D+=" "+B.nodeName.toLowerCase();if(B.nodeValue!=undefined&&B.nodeValue!=false&&B.nodeValue!=null){D+='="'+m(B.nodeValue)+'"'}}return D+">"}while(y.length||z.length){var v=u().splice(0,1)[0];w+=m(x.substr(r,v.offset-r));r=v.offset;if(v.event=="start"){w+=s(v.node);t.push(v.node)}else{if(v.event=="stop"){var q=t.length;do{q--;var p=t[q];w+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);t.splice(q,1);while(q<t.length){w+=s(t[q]);q++}}}}w+=x.substr(r);return w}function i(){function p(u,t,v){if(u.compiled){return}if(!v){u.bR=c(t,u.b?u.b:"\\B|\\b");if(!u.e&&!u.eW){u.e="\\B|\\b"}if(u.e){u.eR=c(t,u.e)}}if(u.i){u.iR=c(t,u.i)}if(u.r==undefined){u.r=1}if(u.k){u.lR=c(t,u.l||hljs.IR,true)}for(var s in u.k){if(!u.k.hasOwnProperty(s)){continue}if(u.k[s] instanceof Object){u.kG=u.k}else{u.kG={keyword:u.k}}break}if(!u.c){u.c=[]}u.compiled=true;for(var r=0;r<u.c.length;r++){p(u.c[r],t,false)}if(u.starts){p(u.starts,t,false)}}for(var q in d){if(!d.hasOwnProperty(q)){continue}p(d[q].dM,d[q],true)}}function e(J,D){if(!i.called){i();i.called=true}function z(r,M){for(var L=0;L<M.c.length;L++){if(M.c[L].bR.test(r)){return M.c[L]}}}function w(L,r){if(C[L].e&&C[L].eR.test(r)){return 1}if(C[L].eW){var M=w(L-1,r);return M?M+1:0}return 0}function x(r,L){return L.iR&&L.iR.test(r)}function A(O,N){var M=[];for(var L=0;L<O.c.length;L++){M.push(O.c[L].b)}var r=C.length-1;do{if(C[r].e){M.push(C[r].e)}r--}while(C[r+1].eW);if(O.i){M.push(O.i)}return c(N,"("+M.join("|")+")",true)}function s(M,L){var N=C[C.length-1];if(!N.t){N.t=A(N,H)}N.t.lastIndex=L;var r=N.t.exec(M);if(r){return[M.substr(L,r.index-L),r[0],false]}else{return[M.substr(L),"",true]}}function p(O,r){var L=H.cI?r[0].toLowerCase():r[0];for(var N in O.kG){if(!O.kG.hasOwnProperty(N)){continue}var M=O.kG[N].hasOwnProperty(L);if(M){return[N,M]}}return false}function F(M,O){if(!O.k){return m(M)}var N="";var P=0;O.lR.lastIndex=0;var L=O.lR.exec(M);while(L){N+=m(M.substr(P,L.index-P));var r=p(O,L);if(r){t+=r[1];N+='<span class="'+r[0]+'">'+m(L[0])+"</span>"}else{N+=m(L[0])}P=O.lR.lastIndex;L=O.lR.exec(M)}N+=m(M.substr(P,M.length-P));return N}function K(r,M){if(M.sL&&d[M.sL]){var L=e(M.sL,r);t+=L.keyword_count;return L.value}else{return F(r,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){q+=L;M.buffer=""}else{if(M.eB){q+=m(r)+L;M.buffer=""}else{q+=L;M.buffer=r}}C.push(M);B+=M.r}function E(O,L,Q){var R=C[C.length-1];if(Q){q+=K(R.buffer+O,R);return false}var M=z(L,R);if(M){q+=K(R.buffer+O,R);I(M,L);return M.rB}var r=w(C.length-1,L);if(r){var N=R.cN?"</span>":"";if(R.rE){q+=K(R.buffer+O,R)+N}else{if(R.eE){q+=K(R.buffer+O,R)+N+m(L)}else{q+=K(R.buffer+O+L,R)+N}}while(r>1){N=C[C.length-2].cN?"</span>":"";q+=N;r--;C.length--}var P=C[C.length-1];C.length--;C[C.length-1].buffer="";if(P.starts){I(P.starts,"")}return R.rE}if(x(L,R)){throw"Illegal"}}var H=d[J];var C=[H.dM];var B=0;var t=0;var q="";try{var v=0;H.dM.buffer="";do{var y=s(D,v);var u=E(y[0],y[1],y[2]);v+=y[0].length;if(!u){v+=y[1].length}}while(!y[2]);if(C.length>1){throw"Illegal"}return{r:B,keyword_count:t,value:q}}catch(G){if(G=="Illegal"){return{r:0,keyword_count:0,value:m(D)}}else{throw G}}}function f(t){var r={keyword_count:0,r:0,value:m(t)};var q=r;for(var p in d){if(!d.hasOwnProperty(p)){continue}var s=e(p,t);s.language=p;if(s.keyword_count+s.r>q.keyword_count+q.r){q=s}if(s.keyword_count+s.r>r.keyword_count+r.r){q=r;r=s}}if(q.language){r.second_best=q}return r}function h(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function o(u,x,q){var y=g(u,q);var s=a(u);if(s=="no-highlight"){return}if(s){var w=e(s,y)}else{var w=f(y);s=w.language}var p=b(u);if(p.length){var r=document.createElement("pre");r.innerHTML=w.value;w.value=l(p,b(r),y)}w.value=h(w.value,x,q);var t=u.className;if(!t.match("(\\s|^)(language-)?"+s+"(\\s|$)")){t=t?(t+" "+s):s}if(/MSIE [678]/.test(navigator.userAgent)&&u.tagName=="CODE"&&u.parentNode.tagName=="PRE"){var r=u.parentNode;var v=document.createElement("div");v.innerHTML="<pre><code>"+w.value+"</code></pre>";u=v.firstChild.firstChild;v.firstChild.cN=r.cN;r.parentNode.replaceChild(v.firstChild,r)}else{u.innerHTML=w.value}u.className=t;u.result={language:s,kw:w.keyword_count,re:w.r};if(w.second_best){u.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function k(){if(k.called){return}k.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=j(r[p]);if(q){o(q,hljs.tabReplace)}}}function n(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",k,false);window.addEventListener("load",k,false)}else{if(window.attachEvent){window.attachEvent("onload",k)}else{window.onload=k}}}var d={};this.LANGUAGES=d;this.highlight=e;this.highlightAuto=f;this.fixMarkup=h;this.highlightBlock=o;this.initHighlighting=k;this.initHighlightingOnLoad=n;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0x[A-Za-z0-9]+|\\d+(\\.\\d+)?)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.inherit=function(p,s){var r={};for(var q in p){r[q]=p[q]}if(s){for(var q in s){r[q]=s[q]}}return r}}();hljs.LANGUAGES.bash=function(){var d={"true":1,"false":1};var b={cN:"variable",b:"\\$([a-zA-Z0-9_]+)\\b"};var a={cN:"variable",b:"\\$\\{(([^}])|(\\\\}))+\\}",c:[hljs.CNM]};var c={cN:"string",b:'"',e:'"',i:"\\n",c:[hljs.BE,b,a],r:0};var e={cN:"test_condition",b:"",e:"",c:[c,b,a,hljs.CNM],k:{literal:d},r:0};return{dM:{k:{keyword:{"if":1,then:1,"else":1,fi:1,"for":1,"break":1,"continue":1,"while":1,"in":1,"do":1,done:1,echo:1,exit:1,"return":1,set:1,declare:1},literal:d},c:[{cN:"shebang",b:"(#!\\/bin\\/bash)|(#!\\/bin\\/sh)",r:10},hljs.HCM,hljs.CNM,c,b,a,hljs.inherit(e,{b:"\\[ ",e:" \\]",r:0}),hljs.inherit(e,{b:"\\[\\[ ",e:" \\]\\]"})]}}}();hljs.LANGUAGES.javascript={dM:{k:{keyword:{"in":1,"if":1,"for":1,"while":1,"finally":1,"var":1,"new":1,"function":1,"do":1,"return":1,"void":1,"else":1,"break":1,"catch":1,"instanceof":1,"with":1,"throw":1,"case":1,"default":1,"try":1,"this":1,"switch":1,"continue":1,"typeof":1,"delete":1},literal:{"true":1,"false":1,"null":1}},c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM,hljs.CNM,{b:"("+hljs.RSR+"|case|return|throw)\\s*",k:{"return":1,"throw":1,"case":1},c:[hljs.CLCM,hljs.CBLCLM,{cN:"regexp",b:"/",e:"/[gim]*",c:[{b:"\\\\/"}]}],r:0},{cN:"function",b:"\\bfunction\\b",e:"{",k:{"function":1},c:[{cN:"title",b:"[A-Za-z$_][0-9A-Za-z$_]*"},{cN:"params",b:"\\(",e:"\\)",c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM]}]}]}};hljs.LANGUAGES.css=function(){var a={cN:"function",b:hljs.IR+"\\(",e:"\\)",c:[{eW:true,eE:true,c:[hljs.NM,hljs.ASM,hljs.QSM]}]};return{cI:true,dM:{i:"[=/|']",c:[hljs.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:{"font-face":1,page:1}},{cN:"at_rule",b:"@",e:"[{;]",eE:true,k:{"import":1,page:1,media:1,charset:1},c:[a,hljs.ASM,hljs.QSM,hljs.NM]},{cN:"tag",b:hljs.IR,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[hljs.CBLCLM,{cN:"rule",b:"[^\\s]",rB:true,e:";",eW:true,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:true,i:"[^\\s]",starts:{cN:"value",eW:true,eE:true,c:[a,hljs.NM,hljs.QSM,hljs.ASM,hljs.CBLCLM,{cN:"hexcolor",b:"\\#[0-9A-F]+"},{cN:"important",b:"!important"}]}}]}]}]}}}();hljs.LANGUAGES.xml=function(){var b="[A-Za-z0-9\\._:-]+";var a={eW:true,c:[{cN:"attribute",b:b,r:0},{b:'="',rB:true,e:'"',c:[{cN:"value",b:'"',eW:true}]},{b:"='",rB:true,e:"'",c:[{cN:"value",b:"'",eW:true}]},{b:"=",c:[{cN:"value",b:"[^\\s/>]+"}]}]};return{cI:true,dM:{c:[{cN:"pi",b:"<\\?",e:"\\?>",r:10},{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style",e:">",k:{title:{style:1}},c:[a],starts:{cN:"css",e:"</style>",rE:true,sL:"css"}},{cN:"tag",b:"<script",e:">",k:{title:{script:1}},c:[a],starts:{cN:"javascript",e:"<\/script>",rE:true,sL:"javascript"}},{cN:"vbscript",b:"<%",e:"%>",sL:"vbscript"},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ />]+"},a]}]}}}();hljs.LANGUAGES.java={dM:{k:{"false":1,"synchronized":1,"int":1,"abstract":1,"float":1,"private":1,"char":1,"interface":1,"boolean":1,"static":1,"null":1,"if":1,"const":1,"for":1,"true":1,"while":1,"long":1,"throw":1,strictfp:1,"finally":1,"protected":1,"extends":1,"import":1,"native":1,"final":1,"implements":1,"return":1,"void":1,"enum":1,"else":1,"break":1,"transient":1,"new":1,"catch":1,"instanceof":1,"byte":1,"super":1,"class":1,"volatile":1,"case":1,assert:1,"short":1,"package":1,"default":1,"double":1,"public":1,"try":1,"this":1,"switch":1,"continue":1,"throws":1},c:[{cN:"javadoc",b:"/\\*\\*",e:"\\*/",c:[{cN:"javadoctag",b:"@[A-Za-z]+"}],r:10},hljs.CLCM,hljs.CBLCLM,hljs.ASM,hljs.QSM,{cN:"class",b:"(class |interface )",e:"{",k:{"class":1,"interface":1},i:":",c:[{b:"(implements|extends)",k:{"extends":1,"implements":1},r:10},{cN:"title",b:hljs.UIR}]},hljs.CNM,{cN:"annotation",b:"@[A-Za-z]+"}]}};hljs.LANGUAGES.haskell=function(){var a={cN:"label",b:"\\b[A-Z][\\w']*",r:0};var b={cN:"container",b:"\\(",e:"\\)",c:[{cN:"label",b:"\\b[A-Z][\\w\\(\\)\\.']*"},{cN:"title",b:"[_a-z][\\w']*"}]};return{dM:{k:{keyword:{let:1,"in":1,"if":1,then:1,"else":1,"case":1,of:1,where:1,"do":1,module:1,"import":1,hiding:1,qualified:1,type:1,data:1,newtype:1,deriving:1,"class":1,instance:1,"null":1,not:1,as:1}},c:[{cN:"comment",b:"--",e:"$"},{cN:"comment",b:"{-",e:"-}"},{cN:"string",b:"\\s+'",e:"'",c:[hljs.BE],r:0},hljs.QSM,{cN:"import",b:"\\bimport",e:"$",k:{"import":1,qualified:1,as:1,hiding:1},c:[b]},{cN:"module",b:"\\bmodule",e:"where",k:{module:1,where:1},c:[b]},{cN:"class",b:"\\b(class|instance|data|(new)?type)",e:"(where|$)",k:{"class":1,where:1,instance:1,data:1,type:1,newtype:1,deriving:1},c:[a]},hljs.CNM,{cN:"shebang",b:"#!\\/usr\\/bin\\/env runhaskell",e:"$"},a,{cN:"title",b:"^[_a-z][\\w']*"}]}}}();hljs.LANGUAGES.sql={cI:true,dM:{i:"[^\\s]",c:[{cN:"operator",b:"(begin|start|commit|rollback|savepoint|lock|alter|create|drop|rename|call|delete|do|handler|insert|load|replace|select|truncate|update|set|show|pragma)\\b",e:";|$",k:{keyword:{all:1,partial:1,global:1,month:1,current_timestamp:1,using:1,go:1,revoke:1,smallint:1,indicator:1,"end-exec":1,disconnect:1,zone:1,"with":1,character:1,assertion:1,to:1,add:1,current_user:1,usage:1,input:1,local:1,alter:1,match:1,collate:1,real:1,then:1,rollback:1,get:1,read:1,timestamp:1,session_user:1,not:1,integer:1,bit:1,unique:1,day:1,minute:1,desc:1,insert:1,execute:1,like:1,ilike:2,level:1,decimal:1,drop:1,"continue":1,isolation:1,found:1,where:1,constraints:1,domain:1,right:1,national:1,some:1,module:1,transaction:1,relative:1,second:1,connect:1,escape:1,close:1,system_user:1,"for":1,deferred:1,section:1,cast:1,current:1,sqlstate:1,allocate:1,intersect:1,deallocate:1,numeric:1,"public":1,preserve:1,full:1,"goto":1,initially:1,asc:1,no:1,key:1,output:1,collation:1,group:1,by:1,union:1,session:1,both:1,last:1,language:1,constraint:1,column:1,of:1,space:1,foreign:1,deferrable:1,prior:1,connection:1,unknown:1,action:1,commit:1,view:1,or:1,first:1,into:1,"float":1,year:1,primary:1,cascaded:1,except:1,restrict:1,set:1,references:1,names:1,table:1,outer:1,open:1,select:1,size:1,are:1,rows:1,from:1,prepare:1,distinct:1,leading:1,create:1,only:1,next:1,inner:1,authorization:1,schema:1,corresponding:1,option:1,declare:1,precision:1,immediate:1,"else":1,timezone_minute:1,external:1,varying:1,translation:1,"true":1,"case":1,exception:1,join:1,hour:1,"default":1,"double":1,scroll:1,value:1,cursor:1,descriptor:1,values:1,dec:1,fetch:1,procedure:1,"delete":1,and:1,"false":1,"int":1,is:1,describe:1,"char":1,as:1,at:1,"in":1,varchar:1,"null":1,trailing:1,any:1,absolute:1,current_time:1,end:1,grant:1,privileges:1,when:1,cross:1,check:1,write:1,current_date:1,pad:1,begin:1,temporary:1,exec:1,time:1,update:1,catalog:1,user:1,sql:1,date:1,on:1,identity:1,timezone_hour:1,natural:1,whenever:1,interval:1,work:1,order:1,cascade:1,diagnostics:1,nchar:1,having:1,left:1,call:1,"do":1,handler:1,load:1,replace:1,truncate:1,start:1,lock:1,show:1,pragma:1},aggregate:{count:1,sum:1,min:1,max:1,avg:1}},c:[{cN:"string",b:"'",e:"'",c:[hljs.BE,{b:"''"}],r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE,{b:'""'}],r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},hljs.CNM,{b:"\\n"}]},hljs.CBLCLM,{cN:"comment",b:"--",e:"$"}]}};hljs.LANGUAGES.nginx=function(){var c={cN:"variable",b:"\\$\\d+"};var b={cN:"variable",b:"\\${",e:"}"};var a={cN:"variable",b:"[\\$\\@]"+hljs.UIR};return{dM:{c:[hljs.HCM,{b:hljs.UIR,e:";|{",rE:true,k:{accept_mutex:1,accept_mutex_delay:1,access_log:1,add_after_body:1,add_before_body:1,add_header:1,addition_types:1,alias:1,allow:1,ancient_browser:1,ancient_browser:1,ancient_browser_value:1,ancient_browser_value:1,auth_basic:1,auth_basic_user_file:1,autoindex:1,autoindex_exact_size:1,autoindex_localtime:1,"break":1,charset:1,charset:1,charset_map:1,charset_map:1,charset_types:1,charset_types:1,client_body_buffer_size:1,client_body_in_file_only:1,client_body_in_single_buffer:1,client_body_temp_path:1,client_body_timeout:1,client_header_buffer_size:1,client_header_timeout:1,client_max_body_size:1,connection_pool_size:1,connections:1,create_full_put_path:1,daemon:1,dav_access:1,dav_methods:1,debug_connection:1,debug_points:1,default_type:1,deny:1,directio:1,directio_alignment:1,echo:1,echo_after_body:1,echo_before_body:1,echo_blocking_sleep:1,echo_duplicate:1,echo_end:1,echo_exec:1,echo_flush:1,echo_foreach_split:1,echo_location:1,echo_location_async:1,echo_read_request_body:1,echo_request_body:1,echo_reset_timer:1,echo_sleep:1,echo_subrequest:1,echo_subrequest_async:1,empty_gif:1,empty_gif:1,env:1,error_log:1,error_log:1,error_page:1,events:1,expires:1,fastcgi_bind:1,fastcgi_buffer_size:1,fastcgi_buffers:1,fastcgi_busy_buffers_size:1,fastcgi_cache:1,fastcgi_cache_key:1,fastcgi_cache_methods:1,fastcgi_cache_min_uses:1,fastcgi_cache_path:1,fastcgi_cache_use_stale:1,fastcgi_cache_valid:1,fastcgi_catch_stderr:1,fastcgi_connect_timeout:1,fastcgi_hide_header:1,fastcgi_ignore_client_abort:1,fastcgi_ignore_headers:1,fastcgi_index:1,fastcgi_intercept_errors:1,fastcgi_max_temp_file_size:1,fastcgi_next_upstream:1,fastcgi_param:1,fastcgi_pass:1,fastcgi_pass_header:1,fastcgi_pass_request_body:1,fastcgi_pass_request_headers:1,fastcgi_read_timeout:1,fastcgi_send_lowat:1,fastcgi_send_timeout:1,fastcgi_split_path_info:1,fastcgi_store:1,fastcgi_store_access:1,fastcgi_temp_file_write_size:1,fastcgi_temp_path:1,fastcgi_upstream_fail_timeout:1,fastcgi_upstream_max_fails:1,flv:1,geo:1,geo:1,geoip_city:1,geoip_country:1,gzip:1,gzip_buffers:1,gzip_comp_level:1,gzip_disable:1,gzip_hash:1,gzip_http_version:1,gzip_min_length:1,gzip_no_buffer:1,gzip_proxied:1,gzip_static:1,gzip_types:1,gzip_vary:1,gzip_window:1,http:1,"if":1,if_modified_since:1,ignore_invalid_headers:1,image_filter:1,image_filter_buffer:1,image_filter_jpeg_quality:1,image_filter_transparency:1,include:1,index:1,internal:1,ip_hash:1,js:1,js_load:1,js_require:1,js_utf8:1,keepalive_requests:1,keepalive_timeout:1,kqueue_changes:1,kqueue_events:1,large_client_header_buffers:1,limit_conn:1,limit_conn_log_level:1,limit_except:1,limit_rate:1,limit_rate_after:1,limit_req:1,limit_req_log_level:1,limit_req_zone:1,limit_zone:1,lingering_time:1,lingering_timeout:1,listen:1,location:1,lock_file:1,log_format:1,log_not_found:1,log_subrequest:1,map:1,map_hash_bucket_size:1,map_hash_max_size:1,master_process:1,memcached_bind:1,memcached_buffer_size:1,memcached_connect_timeout:1,memcached_next_upstream:1,memcached_pass:1,memcached_read_timeout:1,memcached_send_timeout:1,memcached_upstream_fail_timeout:1,memcached_upstream_max_fails:1,merge_slashes:1,min_delete_depth:1,modern_browser:1,modern_browser:1,modern_browser_value:1,modern_browser_value:1,more_clear_headers:1,more_clear_input_headers:1,more_set_headers:1,more_set_input_headers:1,msie_padding:1,msie_refresh:1,multi_accept:1,open_file_cache:1,open_file_cache_errors:1,open_file_cache_events:1,open_file_cache_min_uses:1,open_file_cache_retest:1,open_file_cache_valid:1,open_log_file_cache:1,optimize_server_names:1,output_buffers:1,override_charset:1,override_charset:1,perl:1,perl_modules:1,perl_require:1,perl_set:1,pid:1,port_in_redirect:1,post_action:1,postpone_gzipping:1,postpone_output:1,proxy_bind:1,proxy_buffer_size:1,proxy_buffering:1,proxy_buffers:1,proxy_busy_buffers_size:1,proxy_cache:1,proxy_cache_key:1,proxy_cache_methods:1,proxy_cache_min_uses:1,proxy_cache_path:1,proxy_cache_use_stale:1,proxy_cache_valid:1,proxy_connect_timeout:1,proxy_headers_hash_bucket_size:1,proxy_headers_hash_max_size:1,proxy_hide_header:1,proxy_ignore_client_abort:1,proxy_ignore_headers:1,proxy_intercept_errors:1,proxy_max_temp_file_size:1,proxy_method:1,proxy_next_upstream:1,proxy_pass:1,proxy_pass_header:1,proxy_pass_request_body:1,proxy_pass_request_headers:1,proxy_read_timeout:1,proxy_redirect:1,proxy_send_lowat:1,proxy_send_timeout:1,proxy_set_body:1,proxy_set_header:1,proxy_store:1,proxy_store_access:1,proxy_temp_file_write_size:1,proxy_temp_path:1,proxy_upstream_fail_timeout:1,proxy_upstream_max_fails:1,push_authorized_channels_only:1,push_channel_group:1,push_max_channel_id_length:1,push_max_channel_subscribers:1,push_max_message_buffer_length:1,push_max_reserved_memory:1,push_message_buffer_length:1,push_message_timeout:1,push_min_message_buffer_length:1,push_min_message_recipients:1,push_publisher:1,push_store_messages:1,push_subscriber:1,push_subscriber_concurrency:1,random_index:1,read_ahead:1,real_ip_header:1,recursive_error_pages:1,request_pool_size:1,reset_timedout_connection:1,resolver:1,resolver_timeout:1,"return":1,rewrite:1,rewrite_log:1,root:1,satisfy:1,satisfy_any:1,send_lowat:1,send_timeout:1,sendfile:1,sendfile_max_chunk:1,server:1,server:1,server_name:1,server_name_in_redirect:1,server_names_hash_bucket_size:1,server_names_hash_max_size:1,server_tokens:1,set:1,set_real_ip_from:1,source_charset:1,source_charset:1,ssi:1,ssi_ignore_recycled_buffers:1,ssi_min_file_chunk:1,ssi_silent_errors:1,ssi_types:1,ssi_value_length:1,ssl:1,ssl_certificate:1,ssl_certificate_key:1,ssl_ciphers:1,ssl_client_certificate:1,ssl_crl:1,ssl_dhparam:1,ssl_prefer_server_ciphers:1,ssl_protocols:1,ssl_session_cache:1,ssl_session_timeout:1,ssl_verify_client:1,ssl_verify_depth:1,sub_filter:1,sub_filter_once:1,sub_filter_types:1,tcp_nodelay:1,tcp_nopush:1,timer_resolution:1,try_files:1,types:1,types_hash_bucket_size:1,types_hash_max_size:1,underscores_in_headers:1,uninitialized_variable_warn:1,upstream:1,use:1,user:1,userid:1,userid:1,userid_domain:1,userid_domain:1,userid_expires:1,userid_expires:1,userid_mark:1,userid_name:1,userid_name:1,userid_p3p:1,userid_p3p:1,userid_path:1,userid_path:1,userid_service:1,userid_service:1,valid_referers:1,variables_hash_bucket_size:1,variables_hash_max_size:1,worker_connections:1,worker_cpu_affinity:1,worker_priority:1,worker_processes:1,worker_rlimit_core:1,worker_rlimit_nofile:1,worker_rlimit_sigpending:1,working_directory:1,xml_entities:1,xslt_stylesheet:1,xslt_types:1},r:0,c:[hljs.HCM,{b:"\\s",e:"[;{]",rB:true,rE:true,l:"[a-z/]+",k:{built_in:{on:1,off:1,yes:1,no:1,"true":1,"false":1,none:1,blocked:1,debug:1,info:1,notice:1,warn:1,error:1,crit:1,select:1,permanent:1,redirect:1,kqueue:1,rtsig:1,epoll:1,poll:1,"/dev/poll":1}},r:0,c:[hljs.HCM,{cN:"string",b:'"',e:'"',c:[hljs.BE,c,b,a],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE,c,b,a],r:0},{cN:"string",b:"([a-z]+):/",e:"[;\\s]",rE:true},{cN:"regexp",b:"\\s\\^",e:"\\s|{|;",rE:true,c:[hljs.BE,c,b,a]},{cN:"regexp",b:"~\\*?\\s+",e:"\\s|{|;",rE:true,c:[hljs.BE,c,b,a]},{cN:"regexp",b:"\\*(\\.[a-z\\-]+)+",c:[hljs.BE,c,b,a]},{cN:"regexp",b:"([a-z\\-]+\\.)+\\*",c:[hljs.BE,c,b,a]},{cN:"number",b:"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b"},{cN:"number",b:"\\s\\d+[kKmMgGdshdwy]*\\b",r:0},c,b,a]}]}]}}}();$(function(){
    $.each($("section[id] > h1"), function(i, e){
        var $e = $(e),
            link = $("<a class='permalink'>¶</a>");
        link.attr("href", "#" + $e.parent().attr("id"));

        $e.prepend(link);
    });
});
hljs.initHighlightingOnLoad();
</script><footer id="license" style="text-align:center;font-size:0.8em">All content on this site is available under the
<a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
<br>
Content outside the book section is available under
<a href="https://raw.github.com/yesodweb/yesodweb.com/master/LICENSE">the MIT license</a>
as well.</footer>
</div></div><script>window._gaq = [['_setAccount','UA-1434510-13'],['_trackPageview'],['_trackPageLoadTime']];(function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script><!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body></html>