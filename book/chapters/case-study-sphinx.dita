<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="case-study-sphinx-193"><title>Case Study: Sphinx-based Search</title><conbody>
  <p id="193-x-3"><xref id="193-x-4" href="http://sphinxsearch.com/" format="html" scope="external">Sphinx</xref> is a search
   server, and powers the search feature on many sites, including Yesod's own site. While the actual
   code necessary to integrate Yesod with Sphinx is relatively short, it touches on a number of
   complicated topics, and is therefore a great case study in how to play with some of the
   under-the-surface details of Yesod.</p>
  <p id="193-x-5">There are essentially three different pieces at play here:</p>
  <ul id="193-ul_bqg_pbh_rd">
   <li id="193-x-6">Storing the content we wish to search. This is fairly straight-forward Persistent code, and
    we won't dwell on it much in this chapter.</li>
   <li id="193-x-7">Accessing Sphinx search results from inside Yesod. Thanks to the <apiname id="193-x-8">sphinx</apiname>
    package, this is actually very easy.</li>
   <li id="193-x-9">Providing the document content to Sphinx. This is where the interesting stuff happens, and
    will show how to deal with streaming content from a database directly to XML, which gets sent
    directly over the wire to the client.</li>
  </ul>
 </conbody><concept id="sphinx-setup-194"><title>Sphinx Setup</title><conbody>
  <p id="194-x-3">Unlike many of our other examples, to start with here we'll need to actually configure
   and run our external Sphinx server. I'm not going to go into all the details of Sphinx, partly
   because it's not relevant to our point here, and mostly because I'm not an expert on Sphinx.</p>
  <p id="194-x-4">Sphinx provides three main command line utilities: <codeph id="194-x-5">searchd</codeph>
   is the actual search daemon that receives requests from the client (in this case, our web app)
   and returns the search results. <codeph id="194-x-6">indexer</codeph> parses the set of documents and
   creates the search index. <codeph id="194-x-7">search</codeph> is a debugging utility that will run
   simple queries against Sphinx.</p>
  <p id="194-x-8">There are two important settings: the source and the index. The source tells Sphinx
   where to read document information from. It has direct support for MySQL and PostgreSQL, as well
   as a more general XML format known as xmlpipe2. We're going to use the last one. This not only
   will give us more flexibility with choosing Persistent backends, but will also demonstrate some
   more powerful Yesod concepts.</p>
  <p id="194-x-9">The second setting is the index. Sphinx can handle multiple indices simultaneously,
   which allows it to provide search for multiple services at once. Each index will have a source it
   pulls from.</p>
  <p id="194-x-10">In our case, we're going to provide a URL from our application (/search/xmlpipe) that provides
   the XML file required by Sphinx, and then pipe that through to the indexer. So we'll add the
   following to our Sphinx config file:</p>
  <codeblock id="194-x-11" outputclass="sphinx">source searcher_src
{
	type = xmlpipe2
	xmlpipe_command = curl http://localhost:3000/search/xmlpipe
}

index searcher
{
	source = searcher_src
	path = /var/data/searcher
	docinfo = extern
	charset_type = utf-8
}</codeblock>
  <p id="194-x-12">In order to build your search index, you would run <codeph id="194-x-13">indexer searcher</codeph>. Obviously
   this won't work until you have your web app running. For a production site, it would make sense
   to run this command via a crontab script so the index is regularly updated.</p>
 </conbody></concept><concept id="basic-yesod-setup-195"><title>Basic Yesod Setup</title><conbody>
  <p id="195-x-3">Let's get our basic Yesod setup going. We're going to have a single table in the database for
   holding documents, which consist of a title and content. We'll store this in a SQLite database,
   and provide routes for searching, adding documents, viewing documents and providing the xmlpipe
   file to Sphinx.</p>
  <codeblock id="195-x-4" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Control.Monad.Logger (runStderrLoggingT)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedToMarkup)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)
-- START
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage
-- STOP
addDocForm :: Html -&gt; MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$&gt; areq textField "Title" Nothing
    &lt;*&gt; areq textareaField "Contents" Nothing

searchForm :: Html -&gt; MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing

getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p&gt;Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -&gt; do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
|]

getDocR :: DocId -&gt; Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1&gt;#{docTitle doc}
&lt;div .content&gt;#{docContent doc}
|]

data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [escape $ docContent doc]
        "searcher"
        qstring
    let excerpt =
            case excerpt' of
                ST.Ok t -&gt; preEscapedToMarkup $ T.concat t
                _ -&gt; return ()
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

getResults :: Text -&gt; Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" qstring
    case sphinxRes' of
        ST.Ok sphinxRes -&gt; do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -&gt; do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -&gt; return Nothing
                    Just doc -&gt; liftIO $ Just &lt;$&gt; getResult docid doc qstring
        _ -&gt; error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }

getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -&gt; getResults qstring
            _ -&gt; return []
    defaultLayout $ do
        toWidget [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
$if not $ null searchResults
    &lt;h1&gt;Results
    $forall result &lt;- searchResults
        &lt;div .result&gt;
            &lt;a href=@{DocR $ resultId result}&gt;#{resultTitle result}
            &lt;div .excerpt&gt;#{resultExcerpt result}
|]

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
        flushSource = C.mapOutput C.Chunk source
    sendWaiResponse $ ResponseSource status200 headers flushSource

entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = C.transPipe runStderrLoggingT $ selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -&gt; do
    runStderrLoggingT $ runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</codeblock>
  <p id="195-x-5">Hopefully all of this looks pretty familiar by now. Next we'll define some forms: one for
   creating documents, and one for searching:</p>
  <codeblock id="195-x-6" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Control.Monad.Logger (runStderrLoggingT)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedToMarkup)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage
-- START
addDocForm :: Html -&gt; MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$&gt; areq textField "Title" Nothing
    &lt;*&gt; areq textareaField "Contents" Nothing

searchForm :: Html -&gt; MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing
-- STOP
getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p&gt;Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -&gt; do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
|]

getDocR :: DocId -&gt; Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1&gt;#{docTitle doc}
&lt;div .content&gt;#{docContent doc}
|]

data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [escape $ docContent doc]
        "searcher"
        qstring
    let excerpt =
            case excerpt' of
                ST.Ok t -&gt; preEscapedToMarkup $ T.concat t
                _ -&gt; return ()
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

getResults :: Text -&gt; Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" qstring
    case sphinxRes' of
        ST.Ok sphinxRes -&gt; do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -&gt; do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -&gt; return Nothing
                    Just doc -&gt; liftIO $ Just &lt;$&gt; getResult docid doc qstring
        _ -&gt; error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }

getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -&gt; getResults qstring
            _ -&gt; return []
    defaultLayout $ do
        toWidget [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
$if not $ null searchResults
    &lt;h1&gt;Results
    $forall result &lt;- searchResults
        &lt;div .result&gt;
            &lt;a href=@{DocR $ resultId result}&gt;#{resultTitle result}
            &lt;div .excerpt&gt;#{resultExcerpt result}
|]

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
        flushSource = C.mapOutput C.Chunk source
    sendWaiResponse $ ResponseSource status200 headers flushSource

entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = C.transPipe runStderrLoggingT $ selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -&gt; do
    runStderrLoggingT $ runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</codeblock>
  <p id="195-x-7">The <codeph id="195-x-8">True</codeph> parameter to searchField makes the field auto-focus on page load.
   Finally, we have some standard handlers for the homepage (shows the add document form and the
   search form), the document display, and adding a document.</p>
  <codeblock id="195-x-9" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Control.Monad.Logger (runStderrLoggingT)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedToMarkup)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage

addDocForm :: Html -&gt; MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$&gt; areq textField "Title" Nothing
    &lt;*&gt; areq textareaField "Contents" Nothing

searchForm :: Html -&gt; MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing
-- START
getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p&gt;Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -&gt; do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
|]

getDocR :: DocId -&gt; Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1&gt;#{docTitle doc}
&lt;div .content&gt;#{docContent doc}
|]
-- STOP
data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [escape $ docContent doc]
        "searcher"
        qstring
    let excerpt =
            case excerpt' of
                ST.Ok t -&gt; preEscapedToMarkup $ T.concat t
                _ -&gt; return ()
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

getResults :: Text -&gt; Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" qstring
    case sphinxRes' of
        ST.Ok sphinxRes -&gt; do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -&gt; do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -&gt; return Nothing
                    Just doc -&gt; liftIO $ Just &lt;$&gt; getResult docid doc qstring
        _ -&gt; error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }

getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -&gt; getResults qstring
            _ -&gt; return []
    defaultLayout $ do
        toWidget [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
$if not $ null searchResults
    &lt;h1&gt;Results
    $forall result &lt;- searchResults
        &lt;div .result&gt;
            &lt;a href=@{DocR $ resultId result}&gt;#{resultTitle result}
            &lt;div .excerpt&gt;#{resultExcerpt result}
|]

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
        flushSource = C.mapOutput C.Chunk source
    sendWaiResponse $ ResponseSource status200 headers flushSource

entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = C.transPipe runStderrLoggingT $ selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -&gt; do
    runStderrLoggingT $ runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</codeblock>
 </conbody></concept><concept id="searching-196"><title>Searching</title><conbody>
        <p id="196-x-3">Now that we've got the boring stuff out of the way, let's jump into the actual
            searching. We're going to need three pieces of information for displaying a result: the
            document ID it comes from, the title of that document, and the <term id="196-x-4">excerpts</term>. Excerpts are the highlighted portions of the document which
            contain the search term.</p>
        <fig id="196-x-5">
            <title id="196-x-6">Search Result</title>
            <image href="../images/search-results.png" id="196-image_dba_loh_rd"/>
        </fig>
        <p id="196-x-7">So let's start off by defining a Result datatype:</p>
        <codeblock id="196-x-8" outputclass="haskell">data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }</codeblock>
        <p id="196-x-9">Next we'll look at the search handler:</p>
        <codeblock id="196-x-10" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Control.Monad.Logger (runStderrLoggingT)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedToMarkup)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage

addDocForm :: Html -&gt; MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$&gt; areq textField "Title" Nothing
    &lt;*&gt; areq textareaField "Contents" Nothing

searchForm :: Html -&gt; MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing

getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p&gt;Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -&gt; do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
|]

getDocR :: DocId -&gt; Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1&gt;#{docTitle doc}
&lt;div .content&gt;#{docContent doc}
|]

data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [escape $ docContent doc]
        "searcher"
        qstring
    let excerpt =
            case excerpt' of
                ST.Ok t -&gt; preEscapedToMarkup $ T.concat t
                _ -&gt; ""
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

getResults :: Text -&gt; Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" qstring
    case sphinxRes' of
        ST.Ok sphinxRes -&gt; do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -&gt; do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -&gt; return Nothing
                    Just doc -&gt; liftIO $ Just &lt;$&gt; getResult docid doc qstring
        _ -&gt; error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }

-- START
getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -&gt; getResults qstring
            _ -&gt; return []
    defaultLayout $ do
        toWidget [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
$if not $ null searchResults
    &lt;h1&gt;Results
    $forall result &lt;- searchResults
        &lt;div .result&gt;
            &lt;a href=@{DocR $ resultId result}&gt;#{resultTitle result}
            &lt;div .excerpt&gt;#{resultExcerpt result}
|]
-- STOP

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
        flushSource = C.mapOutput C.Chunk source
    sendWaiResponse $ ResponseSource status200 headers flushSource

entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = C.transPipe runStderrLoggingT $ selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -&gt; do
    runStderrLoggingT $ runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</codeblock>
        <p id="196-x-11">Nothing magical here, we're just relying on the <codeph id="196-x-27">searchForm</codeph> defined above, and the <codeph id="196-x-28">getResults</codeph>
            function which hasn't been defined yet. This function just takes a search string, and
            returns a list of results. This is where we first interact with the Sphinx API. We'll be
            using two functions: <codeph id="196-x-29">query</codeph> will return a list of matches, and
                <codeph id="196-x-30">buildExcerpts</codeph> will return the highlighted excerpts. Let's
            first look at <codeph id="196-x-31">getResults</codeph>:</p>
        <codeblock id="196-x-12" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Control.Monad.Logger (runStderrLoggingT)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedToMarkup)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage

addDocForm :: Html -&gt; MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$&gt; areq textField "Title" Nothing
    &lt;*&gt; areq textareaField "Contents" Nothing

searchForm :: Html -&gt; MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing

getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p&gt;Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -&gt; do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
|]

getDocR :: DocId -&gt; Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1&gt;#{docTitle doc}
&lt;div .content&gt;#{docContent doc}
|]

data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [escape $ docContent doc]
        "searcher"
        qstring
    let excerpt =
            case excerpt' of
                ST.Ok t -&gt; preEscapedToMarkup $ T.concat t
                _ -&gt; ""
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

-- START
getResults :: Text -&gt; Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" qstring
    case sphinxRes' of
        ST.Ok sphinxRes -&gt; do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -&gt; do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -&gt; return Nothing
                    Just doc -&gt; liftIO $ Just &lt;$&gt; getResult docid doc qstring
        _ -&gt; error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }
-- STOP

getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -&gt; getResults qstring
            _ -&gt; return []
    defaultLayout $ do
        toWidget [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
$if not $ null searchResults
    &lt;h1&gt;Results
    $forall result &lt;- searchResults
        &lt;div .result&gt;
            &lt;a href=@{DocR $ resultId result}&gt;#{resultTitle result}
            &lt;div .excerpt&gt;#{resultExcerpt result}
|]

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
        flushSource = C.mapOutput C.Chunk source
    sendWaiResponse $ ResponseSource status200 headers flushSource

entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = C.transPipe runStderrLoggingT $ selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -&gt; do
    runStderrLoggingT $ runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</codeblock>
        <p id="196-x-13"><codeph id="196-x-32">query</codeph> takes three parameters: the configuration
            options, the index to search against (searcher in this case) and the search string. It
            returns a list of document IDs that contain the search string. The tricky bit here is
            that those documents are returned as <codeph id="196-x-14">Int64</codeph> values, whereas we
            need <codeph id="196-x-15">DocId</codeph>s. We're taking advantage of the fact that the SQL
            Persistent backends use a <codeph id="196-x-33">PersistInt64</codeph> constructor for their
            IDs, and simply wrap up the values appropriately.</p>
        <note id="196-x-16">If you're dealing with a backend that has non-numeric IDs, like MongoDB,
            you'll need to work out something a bit more clever than this.</note>
        <p id="196-x-17">We then loop over the resulting IDs to get a <codeph id="196-x-18">[Maybe
                Result]</codeph> value, and use <codeph id="196-x-19">catMaybes</codeph> to turn it into
            a <codeph id="196-x-20">[Result]</codeph>. In the where clause, we define our local
            settings, which override the default port and set up the search to work when <i id="196-x-21">any</i> term matches the document.</p>
        <p id="196-x-22">Let's finally look at the <codeph id="196-x-34">getResult</codeph> function:</p>
        <codeblock id="196-x-23" outputclass="haskell">getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [escape $ docContent doc]
        "searcher"
        qstring
    let excerpt =
            case excerpt' of
                ST.Ok t -&gt; preEscapedToMarkup t
                _ -&gt; ""
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c</codeblock>
        <p id="196-x-24"><codeph id="196-x-35">buildExcerpts</codeph> takes four parameters: the
            configuration options, the textual contents of the document, the search index and the
            search term. The interesting bit is that we entity escape the text content. Sphinx won't
            automatically escape these for us, so we must do it explicitly.</p>
        <p id="196-x-25">Similarly, the result from Sphinx is a list of lazy ByteStrings. But of course,
            we'd rather have Html. So we concat that list into a single lazy ByteString, decode it
            to a lazy text (ignoring invalid UTF-8 character sequences), and use preEscapedToMarkup
            to make sure that the tags inserted for matches are not escaped. A sample of this HTML
            is:</p>
        <codeblock id="196-x-26" outputclass="html">&amp;#8230; Departments.  The President shall have &lt;span class='match'&gt;Power&lt;/span&gt; to fill up all Vacancies
&amp;#8230;  people. Amendment 11 The Judicial &lt;span class='match'&gt;power&lt;/span&gt; of the United States shall
&amp;#8230; jurisdiction. 2. Congress shall have &lt;span class='match'&gt;power&lt;/span&gt; to enforce this article by
&amp;#8230; 5. The Congress shall have &lt;span class='match'&gt;power&lt;/span&gt; to enforce, by appropriate legislation
&amp;#8230;</codeblock>
    </conbody></concept><concept id="xmlpipe-197"><title>Streaming xmlpipe output</title><conbody>
  <p id="197-x-3">We've saved the best for last. For the majority of Yesod handlers, the recommended approach is
   to load up the database results into memory and then produce the output document based on that.
   It's simpler to work with, but more importantly it's more resilient to exceptions. If there's a
   problem loading the data from the database, the user will get a proper 500 response code.</p>
  <note id="197-x-4">What do I mean by "proper 500 response code?" If you start streaming a response to a client,
   and encounter an exception halfway through, there's no way to change the status code; the user
   will see a 200 response that simply stops in the middle. Not only can this partial content be
   confusing, but it's an invalid usage of the HTTP spec.</note>
  <p id="197-x-5">However, generating the xmlpipe output is a perfect example of the alternative. There are
   potentially a huge number of documents (the yesodweb.com code handles tens of thousands of
   these), and documents could easily be several hundred kilobytes. If we take a non-streaming
   approach, this can lead to huge memory usage and slow response times.</p>
  <p id="197-x-6">So how exactly do we create a streaming response? As we cover in <xref id="197-x-7" href="web-application-interface.dita#web-application-interface-242" format="dita">the WAI chapter</xref>, we have a <codeph id="197-x-39">ResponseSource</codeph> constructor that
   uses a stream of blaze-builder <codeph id="197-x-8">Builder</codeph>s. From the Yesod side, we can
   avoid the normal Yesod response procedure and send a WAI response directly using the <codeph id="197-x-9">sendWaiResponse</codeph> function. So there are at least two of the pieces of this
   puzzle.</p>
  <p id="197-x-10">Now we know we want to create a stream of <codeph id="197-x-40">Builder</codeph>s from some XML
   content. Fortunately, the <apiname id="197-x-11">xml-conduit</apiname> package provides this
   interface directly. <codeph id="197-x-41">xml-conduit</codeph> provides some high-level interfaces for dealing
   with documents as a whole, but in our case, we're going to need to use the low-level Event
   interface to ensure minimal memory impact. So the function we're interested in is:</p>
  <codeblock id="197-x-12" outputclass="haskell">renderBuilder :: Resource m =&gt; RenderSettings -&gt; Conduit Event m Builder b</codeblock>
  <p id="197-x-13">In plain English, that means renderBuilder takes some settings (we'll just use the
   defaults), and will then convert a stream of <codeph id="197-x-42">Event</codeph>s to a stream of
    <codeph id="197-x-43">Builder</codeph>s. This is looking pretty good, all we need now is a stream of
    <codeph id="197-x-44">Event</codeph>s.</p>
  <p id="197-x-14">Speaking of which, what should our XML document actually look like? It's pretty
   simple, we have a <codeph id="197-x-15">sphinx:docset</codeph> root element, a <codeph id="197-x-16">sphinx:schema</codeph> element containing a single <codeph id="197-x-17">sphinx:field</codeph>
   (which defines the content field), and then a <codeph id="197-x-18">sphinx:document</codeph> for each
   document in our database. That last element will have an <codeph id="197-x-45">id</codeph> attribute and a
   child <codeph id="197-x-19">content</codeph> element.</p>
  <fig id="197-x-20">
   <title id="197-x-21">Sample xmlpipe document</title>
   <codeblock id="197-x-22" outputclass="xml">&lt;sphinx:docset xmlns:sphinx="http://sphinxsearch.com/"&gt;
    &lt;sphinx:schema&gt;
        &lt;sphinx:field name="content"/&gt;
    &lt;/sphinx:schema&gt;
    &lt;sphinx:document id="1"&gt;
        &lt;content&gt;bar&lt;/content&gt;
    &lt;/sphinx:document&gt;
    &lt;sphinx:document id="2"&gt;
        &lt;content&gt;foo bar baz&lt;/content&gt;
    &lt;/sphinx:document&gt;
&lt;/sphinx:docset&gt;</codeblock>
  </fig>
  <p id="197-x-23">Every document is going to start off with the same events (start the docset, start
   the schema, etc) and end with the same event (end the docset). We'll start off by defining
   those:</p>
  <codeblock id="197-x-24" outputclass="haskell">toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]</codeblock>
  <p id="197-x-25">Now that we have the shell of our document, we need to get the <codeph id="197-x-26">Event</codeph>s for each individual document. This is actually a fairly simple function:</p>
  <codeblock id="197-x-27" outputclass="haskell">entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]</codeblock>
  <p id="197-x-28">We start the document element with an <codeph id="197-x-46">id</codeph> attribute, start the
   content, insert the content, and then close both elements. We use <codeph id="197-x-47">toPathPiece</codeph> to
   convert a <codeph id="197-x-48">DocId</codeph> into a <codeph id="197-x-49">Text</codeph> value. Next, we need to be able to
   convert a stream of these entities into a stream of events. For this, we can use the built-in
    <codeph id="197-x-50">concatMap</codeph> function from <codeph id="197-x-51">Data.Conduit.List</codeph>: <codeph id="197-x-29">CL.concatMap entityToEvents</codeph>.</p>
  <p id="197-x-30">But what we <i id="197-x-31">really</i> want is to stream those events directly from the
   database. For most of this book, we've used the <codeph id="197-x-52">selectList</codeph> function, but
   Persistent also provides the (more powerful) <codeph id="197-x-53">selectSourceConn</codeph> function. So we
   end up with the function:</p>
  <codeblock id="197-x-32" outputclass="haskell">docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents</codeblock>
  <p id="197-x-33">The $= operator joins together a source and a conduit into a new source. Now that we
   have our <codeph id="197-x-54">Event</codeph> source, all we need to do is surround it with the document start
   and end events. With <codeph id="197-x-55">Source</codeph>'s <codeph id="197-x-56">Monoid</codeph> instance, this is a piece
   of cake:</p>
  <codeblock id="197-x-34" outputclass="haskell">fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]</codeblock>
  <p id="197-x-35">We're almost there, now we just need to tie it together in
    <codeph id="197-x-57">getXmlpipeR</codeph>. We need to get a database connection to be used. Normally,
   database connections are taken and returned automatically via the <codeph id="197-x-58">runDB</codeph>
   function. In our case, we want to check out a connection and keep it available until the response
   body is completely sent. To do this, we use the <codeph id="197-x-59">takeResource</codeph> function, which
   registers a cleanup action with the <codeph id="197-x-60">ResourceT</codeph> monad.</p>
  <note id="197-x-61">All WAI applications live in a <codeph id="197-x-62">ResourceT</codeph> transformer. You can get more
   information on <codeph id="197-x-63">ResourceT</codeph> in the <xref id="197-x-64" href="conduits.dita#conduits-208" format="dita">conduit appendix</xref>.</note>
  <p id="197-x-36">By default, a resource will not be returned to the pool. This has to do with proper
   exception handling, but is not relevant for our use case. Therefore, we need to force the
   connection to be returned to the pool.</p>
  <codeblock id="197-x-37" outputclass="haskell">getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True let source = fullDocSource conn C.$= renderBuilder def
    sendWaiResponse $ ResponseSource status200 headers source</codeblock>
  <p id="197-x-38">We get our connection pool from the foundation variable, then send a WAI response. We
   use the <codeph id="197-x-65">ResponseSource</codeph> constructor, and provide it the status code, response
   headers, and body.</p>
 </conbody></concept><concept id="full-code-198"><title>Full code</title><conbody>
  <codeblock id="198-x-3" outputclass="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Control.Monad.Logger (runStderrLoggingT)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedToMarkup)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage

addDocForm :: Html -&gt; MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$&gt; areq textField "Title" Nothing
    &lt;*&gt; areq textareaField "Contents" Nothing

searchForm :: Html -&gt; MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing

getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p&gt;Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -&gt; do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
|]

getDocR :: DocId -&gt; Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1&gt;#{docTitle doc}
&lt;div .content&gt;#{docContent doc}
|]

data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [escape $ docContent doc]
        "searcher"
        qstring
    let excerpt =
            case excerpt' of
                ST.Ok t -&gt; preEscapedToMarkup $ T.concat t
                _ -&gt; ""
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

getResults :: Text -&gt; Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" qstring
    case sphinxRes' of
        ST.Ok sphinxRes -&gt; do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -&gt; do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -&gt; return Nothing
                    Just doc -&gt; liftIO $ Just &lt;$&gt; getResult docid doc qstring
        _ -&gt; error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }

getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -&gt; getResults qstring
            _ -&gt; return []
    defaultLayout $ do
        toWidget [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
$if not $ null searchResults
    &lt;h1&gt;Results
    $forall result &lt;- searchResults
        &lt;div .result&gt;
            &lt;a href=@{DocR $ resultId result}&gt;#{resultTitle result}
            &lt;div .excerpt&gt;#{resultExcerpt result}
|]

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
        flushSource = C.mapOutput C.Chunk source
    sendWaiResponse $ ResponseSource status200 headers flushSource

entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = C.transPipe runStderrLoggingT $ selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -&gt; do
    runStderrLoggingT $ runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</codeblock>
 </conbody></concept></concept>
