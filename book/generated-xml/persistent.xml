<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<section id="persistent_persistent">
<title>Persistent</title>
<simpara>Forms deal with the boundary between the user and the application. Another
boundary we need to deal with is between the application and the storage layer.
Whether it be a SQL database, a YAML file, or a binary blob, odds are your
storage layer does not natively understand your application&#8217;s data types, and
you&#8217;ll need to perform some marshaling.  Persistent is Yesod&#8217;s answer to data
storage- a type-safe, universal data store interface for Haskell.</simpara>
<simpara>Haskell has many different database bindings available. However, most of these
have little knowledge of a schema and therefore do not provide useful static
guarantees. They also force database-dependent APIs and data types on the
programmer.</simpara>
<simpara>Some Haskellers have attempted a more revolutionary route: creating Haskell
specific data stores that allow one to easily store any strongly typed Haskell
data. These options are great for certain use cases, but they constrain one to
the storage techniques provided by the library and do not interface well with
other languages.</simpara>
<simpara>In contrast, Persistent allows us to choose among existing databases that are
highly tuned for different data storage use cases, interoperate with other
programming languages, and to use a safe and productive query interface, while
still keeping the type safety of Haskell datatypes.</simpara>
<simpara>Persistent follows the guiding principles of type safety and concise,
declarative syntax. Some other nice features are:</simpara>
<itemizedlist>
<listitem>
<simpara>
Database-agnostic. There is first class support for PostgreSQL, SQLite, MySQL
  and MongoDB, with experimental Redis support.
</simpara>
</listitem>
<listitem>
<simpara>
Convenient data modeling.
  Persistent lets you model relationships and use them in type-safe ways.
  The default type-safe persistent API does not support joins, allowing support for a
  wider number of storage layers.
  Joins and other SQL specific functionality can be achieved through using
  a raw SQL layer (with very little type safety).
  An additional library, <ulink url="https://github.com/bitemyapp/esqueleto">Esqueleto</ulink>,
  builds on top of the Persistent data model, adding type-safe joins and SQL functionality.
</simpara>
</listitem>
<listitem>
<simpara>
Automatic database migrations in non-production environments to speed up
  development.
</simpara>
</listitem>
</itemizedlist>
<simpara>Persistent works well with Yesod, but it is quite
usable on its own as a standalone library. Most of this chapter will address
Persistent on its own.</simpara>
<section id="persistent_synopsis">
<title>Synopsis</title>
<simpara>The required dependencies for the below are: persistent, persistent-sqlite and persistent-template.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import           Control.Monad.IO.Class  (liftIO)
import           Database.Persist
import           Database.Persist.Sqlite
import           Database.Persist.TH

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int Maybe
    deriving Show
BlogPost
    title String
    authorId PersonId
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration migrateAll

    johnId &lt;- insert $ Person "John Doe" $ Just 35
    janeId &lt;- insert $ Person "Jane Doe" Nothing

    insert $ BlogPost "My fr1st p0st" johnId
    insert $ BlogPost "One more for good measure" johnId

    oneJohnPost &lt;- selectList [BlogPostAuthorId ==. johnId] [LimitTo 1]
    liftIO $ print (oneJohnPost :: [Entity BlogPost])

    john &lt;- get johnId
    liftIO $ print (john :: Maybe Person)

    delete janeId
    deleteWhere [BlogPostAuthorId ==. johnId]</programlisting>
<note><simpara>The type annotations in the snippet above are <emphasis role="strong">not</emphasis> required to get your
code to compile, but are present to clarify to the reader the types of each
value.</simpara></note>
</section>
<section id="persistent_solving_the_boundary_issue">
<title>Solving the boundary issue</title>
<simpara>Suppose you are storing information on people in a SQL database. Your table
might look something like:</simpara>
<programlisting language="sql" linenumbering="unnumbered">CREATE TABLE person(id SERIAL PRIMARY KEY, name VARCHAR NOT NULL, age INTEGER)</programlisting>
<simpara>And if you are using a database like PostgreSQL, you can be guaranteed that the
database will never store some arbitrary text in your age field. (The same
cannot be said of SQLite, but let&#8217;s forget about that for now.) To mirror this
database table, you would likely create a Haskell datatype that looks something
like:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">data Person = Person
    { personName :: Text
    , personAge  :: Int
    }</programlisting>
<simpara>It looks like everything is type safe: the database schema matches our Haskell
datatypes, the database ensures that invalid data can never make it into our
data store, and everything is generally awesome. Well, until:</simpara>
<itemizedlist>
<listitem>
<simpara>
You want to pull data from the database, and the database layer gives you the
  data in an untyped format.
</simpara>
</listitem>
<listitem>
<simpara>
You want to find everyone older than 32, and you accidentally write "thirtytwo"
  in your SQL statement. Guess what: that will compile just fine, and you won&#8217;t
  find out you have a problem until runtime.
</simpara>
</listitem>
<listitem>
<simpara>
You decide you want to find the first 10 people alphabetically. No problem&#8230;
  until you make a typo in your SQL. Once again, you don&#8217;t find out until
  runtime.
</simpara>
</listitem>
</itemizedlist>
<simpara>In dynamic languages, the answer to these issues is unit testing. For
everything that <emphasis>can</emphasis> go wrong, make sure you write a test case. But as I am
sure you are aware by now, that doesn&#8217;t jive well with the Yesod approach to
things. We like to take advantage of Haskell&#8217;s strong typing to save us
wherever possible, and data storage is no exception.</simpara>
<simpara>So the question remains: how can we use Haskell&#8217;s type system to save the day?</simpara>
<section id="persistent_types">
<title>Types</title>
<simpara>Like routing, there is nothing intrinsically difficult about type-safe data
access. It just requires a lot of monotonous, error prone, boiler plate code.
As usual, this means we can use the type system to keep us honest. And to avoid
some of the drudgery, we&#8217;ll use a sprinkling of Template Haskell.</simpara>
<simpara><literal>PersistValue</literal> is the basic building block of Persistent. It is a sum type that
can represent data that gets sent to and from a database. Its definition is:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">data PersistValue
    = PersistText Text
    | PersistByteString ByteString
    | PersistInt64 Int64
    | PersistDouble Double
    | PersistRational Rational
    | PersistBool Bool
    | PersistDay Day
    | PersistTimeOfDay TimeOfDay
    | PersistUTCTime UTCTime
    | PersistNull
    | PersistList [PersistValue]
    | PersistMap [(Text, PersistValue)]
    | PersistObjectId ByteString
    -- ^ Intended especially for MongoDB backend
    | PersistDbSpecific ByteString
    -- ^ Using 'PersistDbSpecific' allows you to use types
    -- specific to a particular backend</programlisting>
<simpara>A <literal>PersistValue</literal> correlates to a column in a SQL database. In our person example
above, name and age would be our <literal>PersistValues</literal>s.</simpara>
<simpara>Each Persistent backend needs to know how to translate the relevant values into
something the database can understand. However, it would be awkward to have to
express all of our data simply in terms of these basic types. The next layer is
the <literal>PersistField</literal> typeclass, which defines how an arbitrary Haskell datatype
can be marshaled to and from a <literal>PersistValue</literal>.</simpara>
<simpara>To tie up the user side of the code, our last typeclass is <literal>PersistEntity</literal>. An
instance of <literal>PersistEntity</literal> correlates with a table in a SQL database. This
typeclass defines a number of functions and some associated types. To review,
we have the following correspondence between Persistent and SQL:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">SQL</entry>
<entry align="left" valign="top">Persistent</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Datatypes (VARCHAR, INTEGER, etc)</simpara></entry>
<entry align="left" valign="top"><simpara>PersistValue</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Column</simpara></entry>
<entry align="left" valign="top"><simpara>PersistField</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Table</simpara></entry>
<entry align="left" valign="top"><simpara>PersistEntity</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="persistent_code_generation">
<title>Code Generation</title>
<simpara>In order to ensure that the PersistEntity instances match up properly with your
Haskell datatypes, Persistent takes responsibility for both. This is also good
from a DRY (Don&#8217;t Repeat Yourself) perspective: you only need to define your
entities once. Let&#8217;s see a quick example:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE UndecidableInstances       #-}
import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

mkPersist sqlSettings [persistLowerCase|
Person
    name String
    age Int
    deriving Show
|]</programlisting>
<simpara>We use a combination of Template Haskell and Quasi-Quotation (like when
defining routes): <literal>persistLowerCase</literal> is a quasi-quoter which converts a
whitespace-sensitive syntax into a list of entity definitions. "Lower case"
refers to the format of the generated table names. In this scheme, an
entity like <literal>SomeTable</literal> would become the SQL table <literal>some_table</literal>. You can also
declare your entities in a separate file using <literal>persistFileWith</literal>. <literal>mkPersist</literal>
takes that list of entities and declares:</simpara>
<itemizedlist>
<listitem>
<simpara>
One Haskell datatype for each entity.
</simpara>
</listitem>
<listitem>
<simpara>
A <literal>PersistEntity</literal> instance for each datatype defined.
</simpara>
</listitem>
</itemizedlist>
<simpara>The example above generates code that looks like the following:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE TypeFamilies, GeneralizedNewtypeDeriving, OverloadedStrings, GADTs #-}
import Database.Persist
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)
import Control.Applicative

data Person = Person
    { personName :: !String
    , personAge :: !Int
    }
  deriving Show

type PersonId = Key Person

instance PersistEntity Person where
    newtype Key Person = PersonKey (BackendKey SqlBackend)
        deriving (PersistField, Show, Eq, Read, Ord)
    -- A Generalized Algebraic Datatype (GADT).
    -- This gives us a type-safe approach to matching fields with
    -- their datatypes.
    data EntityField Person typ where
        PersonId   :: EntityField Person PersonId
        PersonName :: EntityField Person String
        PersonAge  :: EntityField Person Int

    data Unique Person
    type PersistEntityBackend Person = SqlBackend

    toPersistFields (Person name age) =
        [ SomePersistField name
        , SomePersistField age
        ]

    fromPersistValues [nameValue, ageValue] = Person
        &lt;$&gt; fromPersistValue nameValue
        &lt;*&gt; fromPersistValue ageValue
    fromPersistValues _ = Left "Invalid fromPersistValues input"

    -- Information on each field, used internally to generate SQL statements
    persistFieldDef PersonId = FieldDef
        (HaskellName "Id")
        (DBName "id")
        (FTTypeCon Nothing "PersonId")
        SqlInt64
        []
        True
        NoReference
    persistFieldDef PersonName = FieldDef
        (HaskellName "name")
        (DBName "name")
        (FTTypeCon Nothing "String")
        SqlString
        []
        True
        NoReference
    persistFieldDef PersonAge = FieldDef
        (HaskellName "age")
        (DBName "age")
        (FTTypeCon Nothing "Int")
        SqlInt64
        []
        True
        NoReference</programlisting>
<simpara>As you might expect, our <literal>Person</literal> datatype closely matches the definition we
gave in the original Template Haskell version. We also have a Generalized
Algebraic Datatype (GADT) which gives a separate constructor for each field.
This GADT encodes both the type of the entity and the type of the field. We use
its constructors throughout Persistent, such as to ensure that when we apply a
filter, the types of the filtering value match the field. There&#8217;s another
associated newtype for the database primary key of this entity.</simpara>
<simpara>We can use the generated <literal>Person</literal> type like any other Haskell type, and then
pass it off to other Persistent functions.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}

import           Control.Monad.IO.Class  (liftIO)
import           Database.Persist
import           Database.Persist.Sqlite
import           Database.Persist.TH
import           Control.Monad.IO.Unlift
import           Data.Text
import           Control.Monad.Reader
import           Control.Monad.Logger
import           Conduit

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int Maybe
    deriving Show
|]

runSqlite' :: (MonadUnliftIO m) =&gt; Text -&gt; ReaderT SqlBackend (NoLoggingT (ResourceT m)) a -&gt; m a
runSqlite' = runSqlite

main :: IO ()
main = runSqlite' ":memory:" $ do
    michaelId &lt;- insert $ Person "Michael" $ Just 26
    michael &lt;- get michaelId
    liftIO $ print michael</programlisting>
<note><simpara>This code compiles, but will generate a runtime exception about a missing
table. We&#8217;ll explain and address that problem below.</simpara></note>
<simpara>We start off with some standard database connection code. In this case, we used
the single-connection functions. Persistent also comes built in with connection
pool functions, which we will generally want to use in production.</simpara>
<simpara>In this example, we have seen two functions: <literal>insert</literal> creates a new record in
the database and returns its ID. Like everything else in Persistent, IDs are
type safe. We&#8217;ll get into more details of how these IDs work later. So when you
call <literal>insert $ Person "Michael" 26</literal>, it gives you a value back of type
<literal>PersonId</literal>.</simpara>
<simpara>The next function we see is <literal>get</literal>, which attempts to load a value from the
database using an <literal>Id</literal>. In Persistent, you never need to worry that you are
using the key from the wrong table: trying to load up a different entity (like
<literal>House</literal>) using a <literal>PersonId</literal> will never compile.</simpara>
</section>
<section id="persistent_persiststore">
<title>PersistStore</title>
<simpara>One last detail is left unexplained from the previous example: what exactly
does <literal>runSqlite</literal> do, and what is that monad that our database actions are
running in?</simpara>
<simpara>All database actions require a parameter which is an instance of
<literal>PersistStore</literal>. As its name implies, every data store (PostgreSQL, SQLite,
MongoDB) has an instance of <literal>PersistStore</literal>. This is where all the translations
from <literal>PersistValue</literal> to database-specific values occur, where SQL query
generation happens, and so on.</simpara>
<note><simpara>As you can imagine, even though <literal>PersistStore</literal> provides a safe,
well-typed interface to the outside world, there are a lot of database
interactions that could go wrong. However, by testing this code automatically
and thoroughly in a single location, we can centralize our error-prone code and
make sure it is as bug-free as possible.</simpara></note>
<simpara><literal>runSqlite</literal> creates a single connection to a database using its supplied
connection string. For our test cases, we will use <literal>:memory:</literal>, which uses an
in-memory database. All of the SQL backends share the same instance of
<literal>PersistStore</literal>: <literal>SqlBackend</literal>. <literal>runSqlite</literal> then provides the <literal>SqlBackend</literal> value
as an environment parameter to the action via <literal>runReaderT</literal>.</simpara>
<note><simpara>There are actually a few other typeclasses: <literal>PersistUpdate</literal> and
<literal>PersistQuery</literal>. Different typeclasses provide different functionality, which
allows us to write backends that use simpler data stores (e.g., Redis) even
though they can&#8217;t provide us all the high-level functionality available in
Persistent.</simpara></note>
<simpara>One important thing to note is that everything which occurs inside a single
call to <literal>runSqlite</literal> runs in a single transaction. This has two important
implications:</simpara>
<itemizedlist>
<listitem>
<simpara>
For many databases, committing a transaction can be a costly activity. By
  putting multiple steps into a single transaction, you can speed up code
  dramatically.
</simpara>
</listitem>
<listitem>
<simpara>
If an exception is thrown anywhere inside a single call to <literal>runSqlite</literal>, all
  actions will be rolled back (assuming your backend has rollback support).
</simpara>
<note><simpara>This actually has farther-reaching impact than it may initially seem. A
number of the short-circuit functions in Yesod, such as redirects, are
implemented using exceptions. If you use such a call from inside a Persistent
block, it will roll back the entire transaction.</simpara></note>
</listitem>
</itemizedlist>
</section>
</section>
<section id="persistent_migrations">
<title>Migrations</title>
<simpara>I&#8217;m sorry to tell you, but so far I have lied to you a bit: the example from
the previous section does not actually work. If you try to run it, you will get
an error message about a missing table.</simpara>
<simpara>For SQL databases, one of the major pains can be managing schema changes.
Instead of leaving this to the user, Persistent steps in to help, but you have
to <emphasis>ask</emphasis> it to help. Let&#8217;s see what this looks like:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}

import           Control.Monad.IO.Class  (liftIO)
import           Database.Persist
import           Database.Persist.Sqlite
import           Database.Persist.TH
import           Control.Monad.IO.Unlift
import           Data.Text
import           Control.Monad.Reader
import           Control.Monad.Logger
import           Conduit

share [mkPersist sqlSettings, mkEntityDefList "entityDefs", mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int Maybe
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration $ migrate entityDefs $ entityDef (Nothing :: Maybe Person)
    michaelId &lt;- insert $ Person "Michael" $ Just 26
    michael &lt;- get michaelId
    liftIO $ print michael</programlisting>
<simpara>With this one little code change, Persistent will automatically create your
<literal>Person</literal> table for you. This split between <literal>runMigration</literal> and <literal>migrate</literal> allows
you to migrate multiple tables simultaneously.</simpara>
<note><simpara>Using automated database migrations is only recommended in development
environments. Allowing your application to modify your database schema in
a production environment is <emphasis>very strongly discouraged</emphasis>. Automated migrations
can be used to help speed up development, but are not a replacement for manual
review and testing that should take place before production deployments.</simpara></note>
<simpara>This works when dealing with just a few entities, but can quickly get tiresome
once we are dealing with a dozen entities. Instead of repeating yourself,
Persistent provides a helper function, <literal>mkMigrate</literal>:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int
    deriving Show
Car
    color String
    make String
    model String
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do runMigration migrateAll</programlisting>
<simpara><literal>mkMigrate</literal> is a Template Haskell function which creates a new function that
will automatically call <literal>migrate</literal> on all entities defined in the <literal>persist</literal>
block. The <literal>share</literal> function is just a little helper that passes the information
from the persist block to each Template Haskell function and concatenates the
results.</simpara>
<simpara>Persistent has very conservative rules about what it will do during a
migration. It starts by loading up table information from the database,
complete with all defined SQL datatypes. It then compares that against the
entity definition given in the code. For the following cases, it will
automatically alter the schema:</simpara>
<itemizedlist>
<listitem>
<simpara>
The datatype of a field changed. However, the database may object to this
  modification if the data cannot be translated.
</simpara>
</listitem>
<listitem>
<simpara>
A field was added. However, if the field is not null, no default value is
  supplied (we&#8217;ll discuss defaults later) and there is already data in the
  database, the database will not allow this to happen.
</simpara>
</listitem>
<listitem>
<simpara>
A field is converted from not null to null. In the opposite case, Persistent
  will attempt the conversion, contingent upon the database&#8217;s approval.
</simpara>
</listitem>
<listitem>
<simpara>
A brand new entity is added.
</simpara>
</listitem>
</itemizedlist>
<simpara>However, there are some cases that Persistent will not handle:</simpara>
<itemizedlist>
<listitem>
<simpara>
Field or entity renames: Persistent has no way of knowing that "name" has now
  been renamed to "fullName": all it sees is an old field called name and a new
  field called fullName.
</simpara>
</listitem>
<listitem>
<simpara>
Field removals: since this can result in data loss, Persistent by default
  will refuse to perform the action (you can force the issue by using
  <literal>runMigrationUnsafe</literal> instead of <literal>runMigration</literal>, though it is <emphasis role="strong">not</emphasis>
  recommended).
</simpara>
</listitem>
</itemizedlist>
<simpara><literal>runMigration</literal> will print out the migrations it is running on <literal>stderr</literal> (you can
bypass this by using <literal>runMigrationSilent</literal>). Whenever possible, it uses <literal>ALTER
TABLE</literal> calls. However, in SQLite, <literal>ALTER TABLE</literal> has very limited abilities, and
therefore Persistent must resort to copying the data from one table to another.</simpara>
<simpara>Finally, if instead of <emphasis>performing</emphasis> a migration, you want Persistent to give
you hints about what migrations are necessary, use the <literal>printMigration</literal>
function. This function will print out the migrations which <literal>runMigration</literal>
would perform for you. This may be useful for performing migrations that
Persistent is not capable of, for adding arbitrary SQL to a migration, or just
to log what migrations occurred.</simpara>
</section>
<section id="persistent_uniqueness">
<title>Uniqueness</title>
<simpara>In addition to declaring fields within an entity, you can also declare
uniqueness constraints. A typical example would be requiring that a username be
unique.</simpara>
<programlisting language="persistent" linenumbering="unnumbered">User
    username Text
    UniqueUsername username</programlisting>
<simpara>While each field name must begin with a lowercase letter, the uniqueness
constraints must begin with an uppercase letter, since it will be represented
in Haskell as a data constructor.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time
import Control.Monad.IO.Class (liftIO)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    firstName String
    lastName String
    age Int
    PersonName firstName lastName
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration migrateAll
    insert $ Person "Michael" "Snoyman" 26
    michael &lt;- getBy $ PersonName "Michael" "Snoyman"
    liftIO $ print michael</programlisting>
<simpara>To declare a unique combination of fields, we add an extra line to our
declaration. Persistent knows that it is defining a unique constructor, since
the line begins with a capital letter. Each following word must be a field in
this entity.</simpara>
<simpara>The main restriction on uniqueness is that it can only be applied to non-null
fields. The reason for this is that the SQL standard is ambiguous on how
uniqueness should be applied to <literal>NULL</literal> (e.g., is <literal>NULL=NULL</literal> true or false?).
Besides that ambiguity, most SQL engines in fact implement rules which would be
<emphasis>contrary</emphasis> to what the Haskell datatypes anticipate (e.g., PostgreSQL says that
<literal>NULL=NULL</literal> is false, whereas Haskell says <literal>Nothing == Nothing</literal> is <literal>True</literal>).</simpara>
<simpara>In addition to providing nice guarantees at the database level about
consistency of your data, uniqueness constraints can also be used to perform
some specific queries within your Haskell code, like the <literal>getBy</literal> demonstrated
above. This happens via the <literal>Unique</literal> associated type. In the example above, we
end up with a new constructor:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">PersonName :: String -&gt; String -&gt; Unique Person</programlisting>
<note><simpara>With the MongoDB backend, a uniqueness constraint cannot be created: you
must place a unique index on the field.</simpara></note>
</section>
<section id="persistent_queries">
<title>Queries</title>
<simpara>Depending on what your goal is, there are different approaches to querying the
database. Some commands query based on a numeric ID, while others will filter.
Queries also differ in the number of results they return: some lookups should
return no more than one result (if the lookup key is unique) while others can
return many results.</simpara>
<simpara>Persistent therefore provides a few different query functions. As usual, we try
to encode as many invariants in the types as possible. For example, a query
that can return only 0 or 1 results will use a <literal>Maybe</literal> wrapper, whereas a query
returning many results will return a list.</simpara>
<section id="persistent_fetching_by_id">
<title>Fetching by ID</title>
<simpara>The simplest query you can perform in Persistent is getting based on an ID.
Since this value may or may not exist, its return type is wrapped in a <literal>Maybe</literal>.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">personId &lt;- insert $ Person "Michael" "Snoyman" 26
maybePerson &lt;- get personId
case maybePerson of
    Nothing -&gt; liftIO $ putStrLn "Just kidding, not really there"
    Just person -&gt; liftIO $ print person</programlisting>
<simpara>This can be very useful for sites that provide URLs like <emphasis>/person/5</emphasis>. However,
in such a case, we don&#8217;t usually care about the <literal>Maybe</literal> wrapper, and just want
the value, returning a 404 message if it is not found. Fortunately, the
<literal>get404</literal> (provided by the yesod-persistent package) function helps us out here.
We&#8217;ll go into more details when we see integration with Yesod.</simpara>
</section>
<section id="persistent_fetching_by_unique_constraint">
<title>Fetching by unique constraint</title>
<simpara><literal>getBy</literal> is almost identical to <literal>get</literal>, except:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
it takes a uniqueness constraint; that is, instead of an ID it takes a <literal>Unique</literal> value.
</simpara>
</listitem>
<listitem>
<simpara>
it returns an <literal>Entity</literal> instead of a value. An <literal>Entity</literal> is a combination of database ID and value.
</simpara>
</listitem>
</orderedlist>
<programlisting language="haskell" linenumbering="unnumbered">personId &lt;- insert $ Person "Michael" "Snoyman" 26
maybePerson &lt;- getBy $ PersonName "Michael" "Snoyman"
case maybePerson of
    Nothing -&gt; liftIO $ putStrLn "Just kidding, not really there"
    Just (Entity personId person) -&gt; liftIO $ print person</programlisting>
<simpara>Like <literal>get404</literal>, there is also a <literal>getBy404</literal> function.</simpara>
</section>
<section id="persistent_select_functions">
<title>Select functions</title>
<simpara>Most likely, you&#8217;re going to want more powerful queries. You&#8217;ll want to find
everyone over a certain age; all cars available in blue; all users without a
registered email address. For this, you need one of the select functions.</simpara>
<simpara>All the select functions use a similar interface, with slightly different outputs:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Function</entry>
<entry align="left" valign="top">Returns</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>selectSource</simpara></entry>
<entry align="left" valign="top"><simpara>A <literal>Source</literal> containing all the IDs and values from the database. This allows you to write streaming code.</simpara>
<simpara>NOTE: A <literal>Source</literal> is a stream of data, and is part of the <literal>conduit</literal> package. I
recommend reading the
<ulink url="https://github.com/snoyberg/conduit">Official Conduit tutorial</ulink> to get started.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>selectList</simpara></entry>
<entry align="left" valign="top"><simpara>A list containing all the IDs and values from the database. All records will
     be loaded into memory.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>selectFirst</simpara></entry>
<entry align="left" valign="top"><simpara>Takes just the first ID and value from the database, if available</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>selectKeys</simpara></entry>
<entry align="left" valign="top"><simpara>Returns only the keys, without the values, as a <literal>Source</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><literal>selectList</literal> is the most commonly used, so we will cover it specifically. Understanding the others should be trivial after that.</simpara>
<simpara><literal>selectList</literal> takes two arguments: a list of <literal>Filter</literal>s, and a list of
<literal>SelectOpt</literal>s. The former is what limits your results based on
characteristics; it allows for equals, less than, is member of, and such.
<literal>SelectOpt</literal>s provides for three different features: sorting, limiting output
to a certain number of rows, and offsetting results by a certain number of
rows.</simpara>
<note><simpara>The combination of limits and offsets is very important; it allows for
efficient pagination in your webapps.</simpara></note>
<simpara>Let&#8217;s jump straight into an example of filtering, and then analyze it.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">people &lt;- selectList [PersonAge &gt;. 25, PersonAge &lt;=. 30] []
liftIO $ print people</programlisting>
<simpara>As simple as that example is, we really need to cover three points:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>PersonAge</literal> is a constructor for an associated phantom type. That might sound
scary, but what&#8217;s important is that it uniquely identifies the "age" column of
the "person" table, and that it knows that the age field is an <literal>Int</literal>. (That&#8217;s
the phantom part.)
</simpara>
</listitem>
<listitem>
<simpara>
We have a bunch of Persistent filtering operators. They&#8217;re all pretty
straight-forward: just tack a period to the end of what you&#8217;d expect. There are
three gotchas here, I&#8217;ll explain below.
</simpara>
</listitem>
<listitem>
<simpara>
The list of filters is <literal>AND</literal>ed together, so that our constraint means "age is
greater than 25 AND age is less than or equal to 30". We&#8217;ll describe ORing
later.
</simpara>
</listitem>
</orderedlist>
<simpara>The one operator that&#8217;s surprisingly named is "not equals." We use <literal>!=.</literal>, since
<literal>/=.</literal> is used for updates (for "divide-and-set", described later). Don&#8217;t worry:
if you use the wrong one, the compiler will catch you. The other two surprising
operators are the "is member" and "is not member". They are, respectively,
<literal>&lt;-.</literal> and <literal>/&lt;-.</literal> (both end with a period).</simpara>
<simpara>And regarding <literal>OR</literal>s, we use the <literal>||.</literal> operator. For example:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">people &lt;- selectList
    (       [PersonAge &gt;. 25, PersonAge &lt;=. 30]
        ||. [PersonFirstName /&lt;-. ["Adam", "Bonny"]]
        ||. ([PersonAge ==. 50] ||. [PersonAge ==. 60])
    )
    []
liftIO $ print people</programlisting>
<simpara>This (completely nonsensical) example means: find people who are 26-30,
inclusive, OR whose names are neither Adam or Bonny, OR whose age is either 50
or 60.</simpara>
<section id="persistent_selectopt">
<title>SelectOpt</title>
<simpara>All of our <literal>selectList</literal> calls have included an empty list as the second
parameter. That specifies no options, meaning: sort however the database wants,
return all results, and don&#8217;t skip any results. A <literal>SelectOpt</literal> has four
constructors that can be used to change all that.</simpara>
<variablelist>
<varlistentry>
<term>
Asc
</term>
<listitem>
<simpara>
Sort by the given column in ascending order. This uses the same phantom type as filtering, such as <literal>PersonAge</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Desc
</term>
<listitem>
<simpara>
Same as <literal>Asc</literal>, in descending order.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
LimitTo
</term>
<listitem>
<simpara>
Takes an <literal>Int</literal> argument. Only return up to the specified number of results.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
OffsetBy
</term>
<listitem>
<simpara>
Takes an <literal>Int</literal> argument. Skip the specified number of results.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The following code defines a function that will break down results into pages.
It returns all people aged 18 and over, and then sorts them by age (oldest
person first). For people with the same age, they are sorted alphabetically by
last name, then first name.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">resultsForPage pageNumber = do
    let resultsPerPage = 10
    selectList
        [ PersonAge &gt;=. 18
        ]
        [ Desc PersonAge
        , Asc PersonLastName
        , Asc PersonFirstName
        , LimitTo resultsPerPage
        , OffsetBy $ (pageNumber - 1) * resultsPerPage
        ]</programlisting>
</section>
</section>
</section>
<section id="persistent_manipulation">
<title>Manipulation</title>
<simpara>Querying is only half the battle. We also need to be able to add data to and
modify existing data in the database.</simpara>
<section id="persistent_insert">
<title>Insert</title>
<simpara>It&#8217;s all well and good to be able to play with data in the database, but how
does it get there in the first place? The answer is the <literal>insert</literal> function. You
just give it a value, and it gives back an ID.</simpara>
<simpara>At this point, it makes sense to explain a bit of the philosophy behind
Persistent. In many other ORM solutions, the datatypes used to hold data are
opaque: you need to go through their defined interfaces to get at and modify
the data. That&#8217;s not the case with Persistent: we&#8217;re using plain old Algebraic
Data Types for the whole thing. This means you still get all the great benefits
of pattern matching, currying and everything else you&#8217;re used to.</simpara>
<simpara>However, there are a few things we <emphasis>can&#8217;t</emphasis> do. For one, there&#8217;s no way to
automatically update values in the database every time the record is updated in
Haskell. Of course, with Haskell&#8217;s normal stance of purity and immutability,
this wouldn&#8217;t make much sense anyway, so I don&#8217;t shed any tears over it.</simpara>
<simpara>However, there is one issue that newcomers are often bothered by: why are IDs
and values completely separate? It seems like it would be very logical to embed
the ID inside the value. In other words, instead of having:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">data Person = Person { name :: String }</programlisting>
<simpara>have</simpara>
<programlisting language="haskell" linenumbering="unnumbered">data Person = Person { personId :: PersonId, name :: String }</programlisting>
<simpara>Well, there&#8217;s one problem with this right off the bat: how do we do an <literal>insert</literal>? If a Person needs to have an ID, and we get the ID by inserting, and an insert needs a Person, we have an impossible loop. We could solve this with <literal>undefined</literal>, but that&#8217;s just asking for trouble.</simpara>
<simpara>OK, you say, let&#8217;s try something a bit safer:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">data Person = Person { personId :: Maybe PersonId, name :: String }</programlisting>
<simpara>I definitely prefer <literal>insert $ Person Nothing "Michael"</literal> to <literal>insert $ Person
undefined "Michael"</literal>. And now our types will be much simpler, right? For
example, <literal>selectList</literal> could return a simple <literal>[Person]</literal> instead of that ugly
<literal>[Entity SqlPersist Person]</literal>.</simpara>
<simpara>The problem is that the "ugliness" is incredibly useful. Having <literal>Entity Person</literal>
makes it obvious, at the type level, that we&#8217;re dealing with a value that
exists in the database. Let&#8217;s say we want to create a link to another page that
requires the <literal>PersonId</literal> (not an uncommon occurrence as we&#8217;ll discuss later).
The <literal>Entity Person</literal> form gives us unambiguous access to that information;
embedding <literal>PersonId</literal> within <literal>Person</literal> with a <literal>Maybe</literal> wrapper means an extra
runtime check for <literal>Just</literal>, instead of a more error-proof compile time check.</simpara>
<simpara>Finally, there&#8217;s a semantic mismatch with embedding the ID within the value.
The <literal>Person</literal> is the value. Two people are identical (in the context of
Haskell) if all their fields are the same. By embedding the ID in the value,
we&#8217;re no longer talking about a person, but about a row in the database.
Equality is no longer really equality, it&#8217;s identity: is this the <emphasis>same
person</emphasis>, as opposed to an equivalent person.</simpara>
<simpara>In other words, there are some annoyances with having the ID separated out, but
overall, it&#8217;s the <emphasis>right</emphasis> approach, which in the grand scheme of things leads
to better, less buggy code.</simpara>
</section>
<section id="persistent_update">
<title>Update</title>
<simpara>Now, in the context of that discussion, let&#8217;s think about updating. The simplest way to update is:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">let michael = Person "Michael" 26
    michaelAfterBirthday = michael { personAge = 27 }</programlisting>
<simpara>But that&#8217;s not actually updating anything, it&#8217;s just creating a new <literal>Person</literal>
value based on the old one. When we say update, we&#8217;re <emphasis>not</emphasis> talking about
modifications to the values in Haskell. (We better not be of course, since
data in Haskell is immutable.)</simpara>
<simpara>Instead, we&#8217;re looking at ways of modifying rows in a table. And the simplest
way to do that is with the <literal>update</literal> function.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">personId &lt;- insert $ Person "Michael" "Snoyman" 26
update personId [PersonAge =. 27]</programlisting>
<simpara><literal>update</literal> takes two arguments: an ID, and a list of <literal>Update</literal>s. The simplest
update is assignment, but it&#8217;s not always the best. What if you want to
increase someone&#8217;s age by 1, but you don&#8217;t have their current age? Persistent
has you covered:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">haveBirthday personId = update personId [PersonAge +=. 1]</programlisting>
<simpara>And as you might expect, we have all the basic mathematical operators:
<literal>+=.</literal>, <literal>-=.</literal>, <literal>*=.</literal>, and <literal>/=.</literal> (full stop). These can be convenient for
updating a single record, but they are also essential for proper ACID
guarantees. Imagine the alternative: pull out a <literal>Person</literal>, increment the age,
and update the new value. If you have two threads/processes working on this
database at the same time, you&#8217;re in for a world of hurt (hint: race
conditions).</simpara>
<simpara>Sometimes you&#8217;ll want to update many rows at once (give all your employees a
5% pay increase, for example). <literal>updateWhere</literal> takes two parameters: a list of
filters, and a list of updates to apply.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">updateWhere [PersonFirstName ==. "Michael"] [PersonAge *=. 2] -- it's been a long day</programlisting>
<simpara>Occasionally, you&#8217;ll just want to completely replace the value in a database
with a different value. For that, you use (surprise) the <literal>replace</literal> function.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">personId &lt;- insert $ Person "Michael" "Snoyman" 26
replace personId $ Person "John" "Doe" 20</programlisting>
</section>
<section id="persistent_delete">
<title>Delete</title>
<simpara>As much as it pains us, sometimes we must part with our data. To do so, we have three functions:</simpara>
<variablelist>
<varlistentry>
<term>
delete
</term>
<listitem>
<simpara>
Delete based on an ID
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
deleteBy
</term>
<listitem>
<simpara>
Delete based on a unique constraint
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
deleteWhere
</term>
<listitem>
<simpara>
Delete based on a set of filters
</simpara>
</listitem>
</varlistentry>
</variablelist>
<programlisting language="haskell" linenumbering="unnumbered">personId &lt;- insert $ Person "Michael" "Snoyman" 26
delete personId
deleteBy $ PersonName "Michael" "Snoyman"
deleteWhere [PersonFirstName ==. "Michael"]</programlisting>
<simpara>We can even use <literal>deleteWhere</literal> to wipe out all the records in a table, we just
need to give some hints to GHC as to what table we&#8217;re interested in:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">    deleteWhere ([] :: [Filter Person])</programlisting>
</section>
</section>
<section id="persistent_attributes">
<title>Attributes</title>
<simpara>So far, we have seen a basic syntax for our <literal>persistLowerCase</literal> blocks: a line
for the name of our entities, and then an indented line for each field with two
words: the name of the field and the datatype of the field. Persistent handles
more than this: you can assign an arbitrary list of attributes after the first
two words on a line.</simpara>
<simpara>Suppose we want to have a <literal>Person</literal> entity with an (optional) age and the
timestamp of when he/she was added to the system. For entities already in the
database, we want to just use the current date-time for that timestamp.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time
import Control.Monad.IO.Class

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int Maybe
    created UTCTime default=CURRENT_TIME
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    time &lt;- liftIO getCurrentTime
    runMigration migrateAll
    insert $ Person "Michael" (Just 26) time
    insert $ Person "Greg" Nothing time
    return ()</programlisting>
<simpara><literal>Maybe</literal> is a built in, single word attribute. It makes the field optional. In
Haskell, this means it is wrapped in a <literal>Maybe</literal>. In SQL, it makes the column
nullable.</simpara>
<simpara>The <literal>default</literal> attribute is backend specific, and uses whatever syntax is
understood by the database. In this case, it uses the database&#8217;s built-in
<literal>CURRENT_TIME</literal> function. Suppose that we now want to add a field for a person&#8217;s
favorite programming language:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int Maybe
    created UTCTime default=CURRENT_TIME
    language String default='Haskell'
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration migrateAll</programlisting>
<note><simpara>The <literal>default</literal> attribute has absolutely no impact on the Haskell code
itself; you still need to fill in all values. This will only affect the
database schema and automatic migrations.</simpara></note>
<simpara>We need to surround the string with single quotes so that the database can
properly interpret it. Finally, Persistent can use double quotes for containing
white space, so if we want to set someone&#8217;s default home country to be El
Salvador:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int Maybe
    created UTCTime default=CURRENT_TIME
    language String default='Haskell'
    country String "default='El Salvador'"
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration migrateAll</programlisting>
<simpara>One last trick you can do with attributes is to specify the names to be used
for the SQL tables and columns. This can be convenient when interacting with
existing databases.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person sql=the-person-table id=numeric_id
    firstName String sql=first_name
    lastName String sql=fldLastName
    age Int "sql=The Age of the Person"
    PersonName firstName lastName
    deriving Show
|]</programlisting>
<simpara>There are a number of other features to the entity definition syntax. An
up-to-date list is maintained
<ulink url="https://github.com/yesodweb/persistent/blob/master/docs/Persistent-entity-syntax.md">in the Persistent documentation</ulink>.</simpara>
</section>
<section id="persistent_relations">
<title>Relations</title>
<simpara>Persistent allows references between your data types in a manner that is
consistent with supporting non-SQL databases. We do this by embedding an ID in
the related entity. So if a person has many cars:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Control.Monad.IO.Class (liftIO)
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    deriving Show
Car
    ownerId PersonId
    name String
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration migrateAll
    bruce &lt;- insert $ Person "Bruce Wayne"
    insert $ Car bruce "Bat Mobile"
    insert $ Car bruce "Porsche"
    -- this could go on a while
    cars &lt;- selectList [CarOwnerId ==. bruce] []
    liftIO $ print cars</programlisting>
<simpara>Using this technique, you can define one-to-many relationships. To define
many-to-many relationships, we need a join entity, which has a one-to-many
relationship with each of the original tables. It is also a good idea to use
uniqueness constraints on these. For example, to model a situation where we
want to track which people have shopped in which stores:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
Store
    name String
PersonStore
    personId PersonId
    storeId StoreId
    UniquePersonStore personId storeId
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration migrateAll

    bruce &lt;- insert $ Person "Bruce Wayne"
    michael &lt;- insert $ Person "Michael"

    target &lt;- insert $ Store "Target"
    gucci &lt;- insert $ Store "Gucci"
    sevenEleven &lt;- insert $ Store "7-11"

    insert $ PersonStore bruce gucci
    insert $ PersonStore bruce sevenEleven

    insert $ PersonStore michael target
    insert $ PersonStore michael sevenEleven

    return ()</programlisting>
</section>
<section id="persistent_closer_look_at_types">
<title>Closer look at types</title>
<simpara>So far, we&#8217;ve spoken about <literal>Person</literal> and <literal>PersonId</literal> without really explaining
what they are. In the simplest sense, for a SQL-only system, the <literal>PersonId</literal>
could just be <literal>type PersonId = Int64</literal>. However, that means there is nothing
binding a <literal>PersonId</literal> at the type level to the <literal>Person</literal> entity. As a result, you
could accidentally use a <literal>PersonId</literal> and get a <literal>Car</literal>. In order to model this
relationship, we could use phantom types. So, our next naive step would be:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">newtype Key entity = Key Int64
type PersonId = Key Person</programlisting>
<simpara>And that works out really well, until you get to a backend that doesn&#8217;t use
Int64 for its IDs. And that&#8217;s not just a theoretical question; MongoDB uses
<literal>ByteString</literal>s instead. So what we need is a key value that can contain an
<literal>Int</literal> and a <literal>ByteString</literal>. Seems like a great time for a sum type:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">data Key entity = KeyInt Int64 | KeyByteString ByteString</programlisting>
<simpara>But that&#8217;s just asking for trouble. Next we&#8217;ll have a backend that uses
timestamps, so we&#8217;ll need to add another constructor to <literal>Key</literal>. This could go on
for a while. Fortunately, we already have a sum type intended for representing
arbitrary data: <literal>PersistValue</literal>:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">newtype Key entity = Key PersistValue</programlisting>
<simpara>And this is (more or less) what Persistent did until version 2.0. However, this
has a different problem: it throws away data. For example, when dealing with a
SQL database, we know that the key type will be an <literal>Int64</literal> (assuming defaults
are being used). However, you can&#8217;t assert that at the type level with this
construction. So instead, starting with Persistent 2.0, we now use an
associated datatype inside the <literal>PersistEntity</literal> class:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">class PersistEntity record where
    data Key record
    ...</programlisting>
<simpara>When you&#8217;re working with a SQL backend, and aren&#8217;t using a custom key type,
this becomes a newtype wrapper around an <literal>Int64</literal>, and the
<literal>toSqlKey</literal>/<literal>fromSqlKey</literal> functions can perform that type-safe conversion for
you. With MongoDB, on the other hand, it&#8217;s a wrapper around a <literal>ByteString</literal>.</simpara>
<section id="persistent_more_complicated_more_generic">
<title>More complicated, more generic</title>
<simpara>By default, Persistent will hard-code your datatypes to work with a specific
database backend. When using <literal>sqlSettings</literal>, this is the <literal>SqlBackend</literal> type. But
if you want to write Persistent code that can be used on multiple backends, you
can enable more generic types by replacing <literal>sqlSettings</literal> with <literal>sqlSettings {
mpsGeneric = True }</literal>.</simpara>
<simpara>To understand why this is necessary, consider relations.  Let&#8217;s say we want to
represent blogs and blog posts. We would use the entity definition:</simpara>
<screen>Blog
    title Text
Post
    title Text
    blogId BlogId</screen>
<simpara>We know that <literal>BlogId</literal> is just a type synonym for <literal>Key Blog</literal>, but how will <literal>Key
Blog</literal> be defined? We can&#8217;t use an <literal>Int64</literal>, since that won&#8217;t work for MongoDB.
And we can&#8217;t use <literal>ByteString</literal>, since that won&#8217;t work for SQL databases.</simpara>
<simpara>To allow for this, once <literal>mpsGeneric</literal> is set to <literal>True</literal>, our resulting datatypes have a type parameter to indicate the database backend they use, so that keys can be properly encoded. This looks like:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">data BlogGeneric backend = Blog { blogTitle :: Text }
data PostGeneric backend = Post
    { postTitle  :: Text
    , postBlogId :: Key (BlogGeneric backend)
    }</programlisting>
<simpara>Notice that we still keep the short names for the constructors and the records.
Finally, to give a simple interface for normal code, we define some type
synonyms:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">type Blog   = BlogGeneric SqlBackend
type BlogId = Key Blog
type Post   = PostGeneric SqlBackend
type PostId = Key Post</programlisting>
<simpara>And no, <literal>SqlBackend</literal> isn&#8217;t hard-coded into Persistent anywhere. That
<literal>sqlSettings</literal> parameter you&#8217;ve been passing to <literal>mkPersist</literal> is what tells us to
use <literal>SqlBackend</literal>. Mongo code will use <literal>mongoSettings</literal> instead.</simpara>
<simpara>This might be quite complicated under the surface, but user code hardly ever
touches this. Look back through this whole chapter: not once did we need to
deal with the <literal>Key</literal> or <literal>Generic</literal> stuff directly. The most common place for it
to pop up is in compiler error messages. So it&#8217;s important to be aware that
this exists, but it shouldn&#8217;t affect you on a day-to-day basis.</simpara>
</section>
</section>
<section id="persistent_custom_fields">
<title>Custom Fields</title>
<simpara>Occasionally, you will want to define a custom field to be used in your
datastore. The most common case is an enumeration, such as employment status.
For this, Persistent provides a helper Template Haskell function:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">-- @Employment.hs
{-# LANGUAGE TemplateHaskell #-}
module Employment where

import Database.Persist.TH

data Employment = Employed | Unemployed | Retired
    deriving (Show, Read, Eq)
derivePersistField "Employment"</programlisting>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist.Sqlite
import Database.Persist.TH
import Employment

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    employment Employment
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration migrateAll

    insert $ Person "Bruce Wayne" Retired
    insert $ Person "Peter Parker" Unemployed
    insert $ Person "Michael" Employed

    return ()</programlisting>
<simpara><literal>derivePersistField</literal> stores the data in the database using a string field, and
performs marshaling using the <literal>Show</literal> and <literal>Read</literal> instances of the datatype. This
may not be as efficient as storing via an integer, but it is much more future
proof: even if you add extra constructors in the future, your data will still
be valid.</simpara>
<note><simpara>We split our definition into two separate modules in this case. This is
necessary due to the GHC stage restriction, which essentially means that, in
many cases, Template Haskell generated code cannot be used in the same module
it was created in.</simpara></note>
</section>
<section id="persistent_persistent_raw_sql">
<title>Persistent: Raw SQL</title>
<simpara>The Persistent package provides a type safe interface to data stores. It tries
to be backend-agnostic, such as not relying on relational features of SQL. My
experience has been you can easily perform 95% of what you need to do with the
high-level interface. (In fact, most of my web apps use the high level
interface exclusively.)</simpara>
<simpara>But occasionally you&#8217;ll want to use a feature that&#8217;s specific to a backend. One feature I&#8217;ve used in the past is full text search. In this case, we&#8217;ll use the SQL "LIKE" operator, which is not modeled in Persistent. We&#8217;ll get all people with the last name "Snoyman" and print the records out.</simpara>
<note><simpara>Actually, you <emphasis>can</emphasis> express a LIKE operator directly in the normal syntax
due to a feature added in Persistent 0.6, which allows backend-specific
operators. But this is still a good example, so let&#8217;s roll with it.</simpara></note>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import Database.Persist.TH
import Data.Text (Text)
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)
import Data.Conduit
import qualified Data.Conduit.List as CL

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name Text
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    runMigration migrateAll
    insert $ Person "Michael Snoyman"
    insert $ Person "Miriam Snoyman"
    insert $ Person "Eliezer Snoyman"
    insert $ Person "Gavriella Snoyman"
    insert $ Person "Greg Weber"
    insert $ Person "Rick Richardson"

    -- Persistent does not provide the LIKE keyword, but we'd like to get the
    -- whole Snoyman family...
    let sql = "SELECT name FROM Person WHERE name LIKE '%Snoyman'"
    rawQuery sql [] $$ CL.mapM_ (liftIO . print)</programlisting>
<simpara>There is also higher-level support that allows for automated data marshaling.
Please see the Haddock API docs for more details.</simpara>
</section>
<section id="persistent_integration_with_yesod">
<title>Integration with Yesod</title>
<simpara>So you&#8217;ve been convinced of the power of Persistent. How do you integrate it
with your Yesod application? If you use the scaffolding, most of the work is
done for you already. But as we normally do, we&#8217;ll build up everything manually
here to point out how it works under the surface.</simpara>
<simpara>The yesod-persistent package provides the meeting point between Persistent and
Yesod. It provides the <literal>YesodPersist</literal> typeclass, which standardizes access to
the database via the <literal>runDB</literal> method. Let&#8217;s see this in action.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE ViewPatterns               #-}
import Yesod
import Database.Persist.Sqlite
import Control.Monad.Trans.Resource (runResourceT)
import Control.Monad.Logger (runStderrLoggingT)

-- Define our entities as usual
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    firstName String
    lastName String
    age Int
    deriving Show
|]

-- We keep our connection pool in the foundation. At program initialization, we
-- create our initial pool, and each time we need to perform an action we check
-- out a single connection from the pool.
data PersistTest = PersistTest ConnectionPool

-- We'll create a single route, to access a person. It's a very common
-- occurrence to use an Id type in routes.
mkYesod "PersistTest" [parseRoutes|
/ HomeR GET
/person/#PersonId PersonR GET
|]

-- Nothing special here
instance Yesod PersistTest

-- Now we need to define a YesodPersist instance, which will keep track of
-- which backend we're using and how to run an action.
instance YesodPersist PersistTest where
    type YesodPersistBackend PersistTest = SqlBackend

    runDB action = do
        PersistTest pool &lt;- getYesod
        runSqlPool action pool

-- List all people in the database
getHomeR :: Handler Html
getHomeR = do
    people &lt;- runDB $ selectList [] [Asc PersonAge]
    defaultLayout
        [whamlet|
            &lt;ul&gt;
                $forall Entity personid person &lt;- people
                    &lt;li&gt;
                        &lt;a href=@{PersonR personid}&gt;#{personFirstName person}
        |]

-- We'll just return the show value of a person, or a 404 if the Person doesn't
-- exist.
getPersonR :: PersonId -&gt; Handler String
getPersonR personId = do
    person &lt;- runDB $ get404 personId
    return $ show person

openConnectionCount :: Int
openConnectionCount = 10

main :: IO ()
main = runStderrLoggingT $ withSqlitePool "test.db3" openConnectionCount $ \pool -&gt; liftIO $ do
    runResourceT $ flip runSqlPool pool $ do
        runMigration migrateAll
        insert $ Person "Michael" "Snoyman" 26
    warp 3000 $ PersistTest pool</programlisting>
<simpara>There are two important pieces here for general use. <literal>runDB</literal> is used to run a
DB action from within a <literal>Handler</literal>. Within the <literal>runDB</literal>, you can use any of the
functions we&#8217;ve spoken about so far, such as <literal>insert</literal> and <literal>selectList</literal>.</simpara>
<note>
<simpara>The type of <literal>runDB</literal> is <literal>YesodDB site a &#8594; HandlerT site IO a</literal>. <literal>YesodDB</literal> is defined as:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">type YesodDB site = ReaderT (YesodPersistBackend site) (HandlerT site IO)</programlisting>
<simpara>Since it is built on top of the <literal>YesodPersistBackend</literal> associated type, it uses
the appropriate database backend based on the current site.</simpara>
</note>
<simpara>The other new feature is <literal>get404</literal>. It works just like <literal>get</literal>, but instead of
returning a <literal>Nothing</literal> when a result can&#8217;t be found, it returns a 404 message
page. The <literal>getPersonR</literal> function is a very common approach used in real-world
Yesod applications: <literal>get404</literal> a value and then return a response based on it.</simpara>
</section>
<section id="persistent_more_complex_sql">
<title>More complex SQL</title>
<simpara>Persistent strives to be backend-agnostic. The advantage of this approach is
code which easily moves from different backend types. The downside is that you
lose out on some backend-specific features. Probably the biggest casualty is
SQL join support.</simpara>
<simpara>Fortunately, thanks to Felipe Lessa and Chris Allen, you can have your cake and eat it too. The
<ulink url="https://github.com/bitemyapp/esqueleto">Esqueleto</ulink> library provides
support for writing type safe SQL queries, using the existing Persistent
infrastructure. The Haddocks for that package provide a good introduction to
its usage. And since it uses many Persistent concepts, most of your existing
Persistent knowledge should transfer over easily.</simpara>
<simpara>For a simple example of using Esqueleto, please see the SQL Joins chapter.</simpara>
</section>
<section id="persistent_something_besides_sqlite">
<title>Something besides SQLite</title>
<simpara>To keep the examples in this chapter simple, we&#8217;ve used the SQLite backend. Just to round things out, here&#8217;s our original synopsis rewritten to work with PostgreSQL:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE EmptyDataDecls             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
import           Control.Monad.IO.Class  (liftIO)
import           Control.Monad.Logger    (runStderrLoggingT)
import           Database.Persist
import           Database.Persist.Postgresql
import           Database.Persist.TH

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int Maybe
    deriving Show
BlogPost
    title String
    authorId PersonId
    deriving Show
|]

connStr = "host=localhost dbname=test user=test password=test port=5432"

main :: IO ()
main = runStderrLoggingT $ withPostgresqlPool connStr 10 $ \pool -&gt; liftIO $ do
    flip runSqlPersistMPool pool $ do
        runMigration migrateAll

        johnId &lt;- insert $ Person "John Doe" $ Just 35
        janeId &lt;- insert $ Person "Jane Doe" Nothing

        insert $ BlogPost "My fr1st p0st" johnId
        insert $ BlogPost "One more for good measure" johnId

        oneJohnPost &lt;- selectList [BlogPostAuthorId ==. johnId] [LimitTo 1]
        liftIO $ print (oneJohnPost :: [Entity BlogPost])

        john &lt;- get johnId
        liftIO $ print (john :: Maybe Person)

        delete janeId
        deleteWhere [BlogPostAuthorId ==. johnId]</programlisting>
</section>
<section id="persistent_summary">
<title>Summary</title>
<simpara>Persistent brings the type safety of Haskell to your data access layer. Instead
of writing error-prone, untyped data access, or manually writing boilerplate
marshal code, you can rely on Persistent to automate the process for you.</simpara>
<simpara>The goal is to provide everything you need, <emphasis>most</emphasis> of the time. For the times
when you need something a bit more powerful, Persistent gives you direct access
to the underlying data store, so you can write whatever 5-way joins you want.</simpara>
<simpara>Persistent integrates directly into the general Yesod workflow. Not only do
helper packages like <literal>yesod-persistent</literal> provide a nice layer, but packages like
<literal>yesod-form</literal> and <literal>yesod-auth</literal> also leverage Persistent&#8217;s features as well.</simpara>
<simpara>For more information on the syntax of entity declarations, database connection, etc.
Checkout <ulink url="https://github.com/yesodweb/persistent/tree/master/docs">https://github.com/yesodweb/persistent/tree/master/docs</ulink></simpara>
</section>
</section>
</article>
