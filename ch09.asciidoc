[[I_chapter9_d1e4588]]

== Sessions

HTTP is a stateless protocol. While some view this as a disadvantage, advocates of RESTful web development laud this as a plus. When state is removed from the picture, it is easier to scale applications, caching can happen automatically, and many other nice side effects occur. You can draw many parallels with the non-mutable nature of Haskell in general.

As much as possible, RESTful applications should avoid storing state about an interaction with a client. However, it is sometimes unavoidable. Features like shopping carts are the classic example, but other more mundane interactions like proper login handling can be greatly enhanced by proper usage of sessions.

This chapter will describe how Yesod stores session data, how you can access this data, and some special functions to help you make the most of sessions.

[[I_sect19_d1e4600]]

=== Clientsession

One of the earliest packages spun off from Yesod was clientsession. This package uses encryption and signatures to store data in a client-side cookie. The encryption prevents the user from inspecting the data, and the signature ensures that the session can be neither hijacked nor tampered with.

It might sound like a bad idea from an efficiency standpoint to store data in a cookie: after all, this means that the data must be sent on every request. However, in practice, clientsession can be a great boon for performance.


* No server side database lookup is required to service a request.


* We can easily scale horizontally: each request contains all the information we need to send a response.


* To avoid undue bandwidth overhead, production sites can serve their static content from a separate domain name to avoid the overhead of transmitting the session cookie for each request.

Storing megabytes of information in the session will be a bad idea. But for that matter, most session implementations recommend against such practices. If you really need massive storage for a user, it is best to store a lookup key in the session, and put the actual data in a database.

All of the interaction with clientsession is handled by Yesod internally, but there are a few spots where you can tweak the behavior just a bit.

[[I_sect19_d1e4624]]

=== Controlling Sessions

There are three functions in the Yesod typeclass that control how sessions work. encryptKey returns the encryption key used. By default, it will take this from a local file, so that sessions can persist between database shutdowns. This file will be automatically created and filled with random data if it does not exist. And if you override this function to return +Nothing+, sessions will be disabled.


[NOTE]
====
Why disable sessions? They *do* introduce a performance overhead. Under normal circumstances, this overhead is minimal, especially compared to database access. However, when dealing with very basic tasks, the overhead can become noticeable. But be careful about disabling sessions: this will also disable such features as  CSRF (Cross-Site Request Forgery) protection.


====


The next function is clientSessionDuration. This function gives the number of minutes that a session should be active. The default is 120 (2 hours).

This value ends up affecting the session cookie in two ways: first, it determines the expiration date for the cookie itself. More importantly, however, the session expiration timestamp is encoded inside the session signature. When Yesod decodes the signature, it checks whether the date is in the past; if so, it ignores the session values.


[NOTE]
====
Every time Yesod sends a response to the client, it sends an updated session cookie with a new expire date. This way, even if you do not change the session values themselves, a session will not time out if the user continues to browse your site.


====


And this leads very nicely to the last function: sessionIpAddress. By default, Yesod also encodes the client&rsquo;s IP address inside the cookie to prevent session hijacking. In general, this is a good thing. However, some ISPs are known for putting their users behind proxies that rewrite their IP addresses, sometimes changing the source IP in the middle of the session. If this happens, and you have +sessionIpAddress+ enabled, the user&rsquo;s session will be reset. Turning this setting to +False+ will allow a session to continue under such circumstances, at the cost of exposing a user to session hijacking.

[[I_sect19_d1e4665]]

=== Session Operations

Like most frameworks, a session in Yesod is a key-value store. The base session API boils down to four functions: +lookupSession+ gets a value for a key (if available), +getSession+ returns all of the key/value pairs, +setSession+ sets a value for a key, and +deleteSession+ clears a value for a key.


[source, haskell]
----
{-# LANGUAGE TypeFamilies, QuasiQuotes, TemplateHaskell, MultiParamTypeClasses, OverloadedStrings #-}
import Yesod
import Control.Applicative ((<$>), (<*>))

data SessionExample = SessionExample

mkYesod "SessionExample" [parseRoutes|
/ Root GET POST
|]

getRoot :: Handler RepHtml
getRoot = do
    sess <- getSession
    hamletToRepHtml [hamlet|
<form method=post>
    <input type=text name=key>
    <input type=text name=val>
    <input type=submit>
<h1>#{show sess}
|]

postRoot :: Handler ()
postRoot = do
    (key, mval) <- runInputPost $ (,) <$> ireq textField "key" <*> iopt textField "val"
    case mval of
        Nothing -> deleteSession key
        Just val -> setSession key val
    liftIO $ print (key, mval)
    redirect Root

instance Yesod SessionExample where
    clientSessionDuration _ = 1

instance RenderMessage SessionExample FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 SessionExample
----

[[I_sect19_d1e4684]]

=== Messages

One usage of sessions previously alluded to is messages. They come to solve a common problem in web development: the user performs a +POST+ request, the web app makes a change, and then the web app wants to _simultaneously_ redirect the user to a new page and send the user a success message. (This is known as Post/Redirect/Get.)

Yesod provides a pair of functions to make this very easy: +setMessage+ stores a value in the session, and +getMessage+ both reads the value most recently put into the session, and clears the old value so it does not accidently get displayed twice.

It is recommended to have a call to +getMessage+ in +defaultLayout+ so that any available message is shown to a user immediately, without having to remember to add +getMessage+ calls to every handler.


[source, haskell]
----
{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
             QuasiQuotes, MultiParamTypeClasses #-}
import Yesod

data Messages = Messages

mkYesod "Messages" [parseRoutes|
/ RootR GET
/set-message SetMessageR POST
|]

instance Yesod Messages where
    defaultLayout widget = do
        pc <- widgetToPageContent widget
        mmsg <- getMessage
        hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        ^{pageHead pc}
    <body>
        $maybe msg <- mmsg
            <p>Your message was: #{msg}
        ^{pageBody pc}
|]

instance RenderMessage Messages FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
<form method=post action=@{SetMessageR}>
    My message is: #
    <input type=text name=message>
    <input type=submit>
|]

postSetMessageR :: Handler ()
postSetMessageR = do
    msg <- runInputPost $ ireq textField "message"
    setMessage $ toHtml msg
    redirect RootR

main :: IO ()
main = warpDebug 3000 Messages
----

[[messages-x-4]]

.Initial page load, no message
image::figs/dwhy_0901.png[]

[[messages-x-6]]

.New message entered in text box
image::figs/dwhy_0902.png[]

[[messages-x-8]]

.After form submit, message appears at top of page
image::figs/dwhy_0903.png[]

[[messages-x-10]]

.After refresh, the message is cleared
image::figs/dwhy_0904.png[]

[[I_sect19_d1e4748]]

=== Ultimate Destination

Not to be confused with a horror film, this concept is used internally in yesod-auth. Suppose a user requests a page that requires authentication. If the user is not yet logged in, you need to send him/her to the login page. A well-designed web app will then _send them back to the first page they requested_. That&rsquo;s what we call the ultimate destination.

+redirectUltDest+ sends the user to the ultimate destination set in his/her session, clearing that value from the session. It takes a default destination as well, in case there is no destination set. For setting the session, there are three options:

* +setUltDest+ sets the destination to the given URL.


* +setUltDestCurrent+ sets the destination to the currently requested URL.


* +setUltDestReferer+ sets the destination based on the +Referer+ header (the page that led the user to the current page).



Let&rsquo;s look at a small sample app. It will allow the user to set his/her name in the session, and then tell the user his/her name from another route. If the name hasn&rsquo;t been set yet, the user will be redirected to the set name page, with an ultimate destination set to come back to the current page.


[source, haskell]
----
{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
             QuasiQuotes, MultiParamTypeClasses #-}
import Yesod

data UltDest = UltDest

mkYesod "UltDest" [parseRoutes|
/ RootR GET
/setname SetNameR GET POST
/sayhello SayHelloR GET
|]

instance Yesod UltDest

instance RenderMessage UltDest FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR = defaultLayout [whamlet|
<p>
    <a href=@{SetNameR}>Set your name
<p>
    <a href=@{SayHelloR}>Say hello
|]

-- Display the set name form
getSetNameR = defaultLayout [whamlet|
<form method=post>
    My name is #
    <input type=text name=name>
    . #
    <input type=submit value="Set name">
|]

-- Retrieve the submitted name from the user
postSetNameR :: Handler ()
postSetNameR = do
    -- Get the submitted name and set it in the session
    name <- runInputPost $ ireq textField "name"
    setSession "name" name

    -- After we get a name, redirect to the ultimate destination.
    -- If no destination is set, default to the homepage
    redirectUltDest RootR

getSayHelloR = do
    -- Lookup the name value set in the session
    mname <- lookupSession "name"
    case mname of
        Nothing -> do
            -- No name in the session, set the current page as
            -- the ultimate destination and redirect to the
            -- SetName page
            setUltDestCurrent
            setMessage "Please tell me your name"
            redirect SetNameR
        Just name -> defaultLayout [whamlet|
<p>Welcome #{name}
|]

main :: IO ()
main = warpDebug 3000 UltDest
----

[[I_sect19_d1e4786]]

=== Summary

Sessions are the number one way we bypass the statelessness imposed by HTTP. We shouldn&rsquo;t consider this an escape hatch to perform whatever actions we want: statelessness in web applications is a virtue, and we should respect it whenever possible. However, there are specific cases where it is vital to retain some state.

The session API in Yesod is very simple. It provides a key-value store, and a few convenience functions built on top for common use cases. If used properly, with small payloads, sessions should be an unobtrusive part of your web development.

