<p>Sorry if the title sounds like a medical condition...</p>
<p>Anyway, it's been quite busy since releasing the <a href="http://www.yesodweb.com/code.html">Yesod web framework</a>. I got a lot of very useful feedback, especially from Jeremy Shaw and Chris Eidhof. There are two main shortcomings of Yesod (and Haskell web programming in general) that we've discussed:</p>
<ul><li>Persistence</li>
<li>Type-safe URL handling</li>
</ul>
<p>We've had <a href="http://www.haskell.org/pipermail/web-devel/2010/000120.html">a very good discussion about the latter</a> on the <a href="http://www.haskell.org/mailman/listinfo/web-devel">web-devel mailing list</a>; I highly recommend that everyone subscribe to that list by the way.</p>
<p>That discussion inspired me a little bit for a persistence interface, and so I started <a href="http://github.com/snoyberg/persistent">a project today called persistent</a>. The goal is to provide a unified interface to any storage backend, be it SQL, in-memory, YAML files, or Amazon SimpleDB.</p>
<p>At the moment, it only handles String and Int data, allows all CRUD actions and the ability to filter in a very basic way. All of this will need to be augmented to be usable, but it shows the overall structure fairly well. I've also written an in-memory sample storage mechanism; everything together clocks in at <a href="http://github.com/snoyberg/persistent/blob/master/Data/Persist.hs">a single 145 line file</a>.</p>
<p>But that's not the cool part. The cool part is <i>synthesizing these two goals</i> to get completely pluggable web components. As an example, I wrote up a basic web authentication plugin. All of the code <a href="http://github.com/snoyberg/persistent/blob/master/auth-example.hs">is available in the same repository</a>, and is only 164 lines- including a lot of boilerplate HTML.</p>
<p>The approach taken for both sides of the puzzle here is to provide a low-level, tedious, boilerplate-requiring interface that gives the user a lot of power. Both of these pieces can then be automated later through some higher-level mechanism, be it template haskell, generics or (my favorite) quasi-quoting.</p>
<p>If you want to try out the auth example, I've hard-coded michael/michael as the only username/password combination that works. Eventually, when we hammer out a good API for both sides of this, I would like to actually develop a fully-functional authentication plug-in that supports e-mail validation, allows OpenID, Twitter and other external logins, and more. And then any system that supports persistent and the web plug-in system will be able to have a very advanced authentication system for free.</p>
